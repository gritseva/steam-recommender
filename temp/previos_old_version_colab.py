# -*- coding: utf-8 -*-
"""Telegram adaptation "steam_chatbot_1.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p1keVKFTTtew7UxBrxEfplgmz-u4hi16
"""

# ======== Import Libraries & Initialize Models =========

# !pip install fuzzywuzzy
# !pip install python-levenshtein
# !pip install bitsandbytes==0.44.1 transformers==4.46.1 huggingface==0.0.1 huggingface-hub==0.26.2 torch==2.5.1
# !pip install langchain langchain-community
# !pip install sentence_transformers
# !pip install chromadb
# !pip install google-api-python-client
# !pip install dateparser
# !pip install googletrans==4.0.0-rc1
# !pip install python-telegram-bot

# Import necessary libraries
import os
import re
import json
import requests
import numpy as np
import pandas as pd
import dateparser

import tensorflow as tf
import torch
import datetime
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from sklearn.metrics.pairwise import cosine_similarity
from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig
from langchain.llms import HuggingFacePipeline
from fuzzywuzzy import fuzz, process
import joblib
import logging
import torch
from langchain.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import Chroma

from telegram import Update, ChatAction
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext

# !pip install googletrans --upgrade

import httpcore
setattr(httpcore, 'SyncHTTPTransport', 'AsyncHTTPProxy')
import googletrans

# https://steamcommunity.com/dev/apikey
# https://console.cloud.google.com/apis/credentials?project=steam-chatbot-443107

os.environ['STEAM_API_KEY'] = '20C329B6B94FFCEB49EBFBDD80734327'
os.environ['YOUTUBE_API_KEY'] = 'AIzaSyDj7fQZKeKi-pRqvYy1efx3YJJMN598uTo'

# Ensure the device is correctly initialized based on your environment (GPU or CPU)
device = "cuda" if torch.cuda.is_available() else "cpu"

# ======== Load Models and Data =========

# Load and mount drive
from google.colab import drive
drive.mount('/content/drive')

# Load encoders and NCF model
user_encoder = joblib.load('/content/drive/MyDrive/steam_recommender/model_with_tags/user_encoder.pkl')
game_encoder = joblib.load('/content/drive/MyDrive/steam_recommender/model_with_tags/game_encoder.pkl')

import tensorflow as tf
from tensorflow.keras.models import load_model

# Load NCF Model and item embeddings
def load_ncf_model():
    tf.keras.backend.clear_session()
    model_ncf = load_model('/content/drive/MyDrive/steam_recommender/model_with_tags/trained_model.keras', compile=False)
    return model_ncf

ncf_model = load_ncf_model()
item_embeddings = ncf_model.get_layer('item_embedding').get_weights()[0]

from transformers import BitsAndBytesConfig
# Initialize Transformer model and tokenizer
checkpoint_dir = "/content/drive/MyDrive/steam_recommender/saved_checkpoint"


bnb_config = BitsAndBytesConfig(
    load_in_4bit=True,
    bnb_4bit_use_double_quant=True,
    bnb_4bit_quant_type="nf4",
    llm_int8_enable_fp32_cpu_offload=True,
    bnb_4bit_compute_dtype=torch.float16  # Match data types for faster inference
)

# Load the model and tokenizer from the saved checkpoint
tokenizer = AutoTokenizer.from_pretrained(checkpoint_dir, use_fast=False)
model = AutoModelForCausalLM.from_pretrained(
    checkpoint_dir,
    torch_dtype=torch.float16,
    device_map="auto",
    quantization_config=bnb_config
)

print("Model and tokenizer loaded from the saved checkpoint.")

# Ensure eos_token_id and pad_token_id are set
if tokenizer.eos_token_id is None:
    tokenizer.eos_token_id = tokenizer.convert_tokens_to_ids("<|endoftext|>")  # Common EOS token
if tokenizer.pad_token_id is None:
    tokenizer.pad_token_id = tokenizer.eos_token_id

# Load data
games_df = pd.read_csv('/content/drive/MyDrive/steam_recommender/games.csv')
combined_df = pd.read_pickle('/content/drive/MyDrive/steam_recommender/combined_df.pkl')

from langchain.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import Chroma


embedding_model_path = "all-MiniLM-L6-v2"


# Initialize the embedding model
embedding_model = HuggingFaceEmbeddings(model_name=embedding_model_path)

# Specify the persist directory
persist_directory = "/content/drive/MyDrive/steam_recommender/vector_store_minilm_extended"


# Load the vector store
vector_store = Chroma(
    embedding_function=embedding_model,
    persist_directory=persist_directory
)

# Verify the number of documents
doc_count = vector_store._collection.count()
print("Number of documents in vector store:", doc_count)



import json
# Load additional data
games_csv = pd.read_csv('/content/drive/MyDrive/steam_recommender/games.csv')
with open('/content/drive/MyDrive/steam_recommender/games_metadata.json', 'r') as f:
    games_metadata = [json.loads(line.strip()) for line in f]

games_metadata_df = pd.DataFrame(games_metadata)

# Ensure date_release is a datetime object
games_csv['date_release'] = pd.to_datetime(games_csv['date_release'], errors='coerce')

import pandas as pd

# Define the exact column headers based on the data structure provided
column_headers = [
    'AppID', 'Name', 'Release date', 'Estimated owners', 'Peak CCU', 'Required age',
    'Price', 'DiscountDLC count', 'About the game', 'Supported languages', 'Full audio languages',
    'Reviews', 'Header image', 'Website', 'Support url', 'Support email', 'Windows', 'Mac', 'Linux',
    'Metacritic score', 'Metacritic url', 'User score', 'Positive', 'Negative', 'Score rank', 'Achievements',
    'Recommendations', 'Notes', 'Average playtime forever', 'Average playtime two weeks', 'Median playtime forever',
    'Median playtime two weeks', 'Developers', 'Publishers', 'Categories', 'Genres', 'Tags', 'Screenshots', 'Movies'
]

# Load the CSV file with custom column names, skipping the original header row
new_games_data = pd.read_csv('/content/drive/MyDrive/steam_recommender/cleaned_games_developers.csv', names=column_headers, skiprows=1)

# Load the original games data
games_df = pd.read_csv('/content/drive/MyDrive/steam_recommender/games.csv')

# Rename columns in new_games_data for consistency with games_df
new_games_data = new_games_data.rename(columns={
    'AppID': 'app_id',
    'Name': 'title',
    'Release date': 'release_date',
    'Estimated owners': 'estimated_owners',
    'Peak CCU': 'peak_ccu',
    'Required age': 'required_age',
    'Price': 'price',
    'DiscountDLC count': 'discount_dlc_count',
    'About the game': 'about_game',
    'Supported languages': 'supported_languages',
    'Metacritic score': 'metacritic_score',
    'User score': 'user_score',
    'Developers': 'developer',
    'Publishers': 'publisher',
    'Categories': 'categories',
    'Genres': 'genres',
    'Tags': 'tags'
})

# Convert 'app_id' to numeric, coercing non-numeric entries to NaN, then drop NaNs
new_games_data['app_id'] = pd.to_numeric(new_games_data['app_id'], errors='coerce')

# Inspect rows with NaN values in 'app_id' to ensure they're removed
print("Rows with NaN in 'app_id' before dropping:", new_games_data[new_games_data['app_id'].isna()])

# Drop rows where 'app_id' is NaN
new_games_data = new_games_data.dropna(subset=['app_id'])

# Re-check for NaN or non-numeric values in 'app_id' after drop
print("Remaining NaNs in 'app_id':", new_games_data['app_id'].isna().sum())

# Convert 'app_id' to int now that it is clean
new_games_data['app_id'] = new_games_data['app_id'].astype(int)

# Ensure 'app_id' in games_df is also in integer format for consistency
games_df['app_id'] = games_df['app_id'].astype(int)

# Merge new_games_data with games_df, keeping only one version of overlapping columns
games_df_merged = games_df.merge(new_games_data, on='app_id', how='left', suffixes=('', '_new'))

# Drop any redundant columns created during the merge
redundant_columns = [col for col in games_df_merged.columns if col.endswith('_new')]
games_df_merged = games_df_merged.drop(columns=redundant_columns, errors='ignore')

# Display first few rows of the merged DataFrame for verification
print(games_df_merged.head())

# Merge games_metadata with games_df_merged
games_complete_df = games_df_merged.merge(games_metadata_df[['app_id', 'description']], on='app_id', how='left')
# Normalize the 'genres' column into lists (if it's stored as comma-separated strings)
games_complete_df['genres'] = games_complete_df['genres'].apply(lambda x: [genre.strip().lower() for genre in x.split(',')] if isinstance(x, str) else [])

def filter_games(games_df, min_positive_ratio=70, min_user_reviews=100, min_rating='Positive', earliest_release_year=2000):
    # Define acceptable ratings
    acceptable_ratings = ['Positive', 'Very Positive', 'Overwhelmingly Positive']

    # Convert rating to categorical for comparison
    rating_order = {
        'Overwhelmingly Positive': 4,
        'Very Positive': 3,
        'Positive': 2,
        'Mostly Positive': 1,
        'Mixed': 0,
        'Mostly Negative': -1,
        'Negative': -2,
        'Very Negative': -3,
        'Overwhelmingly Negative': -4
    }
    games_df['rating_value'] = games_df['rating'].map(rating_order)
    min_rating_value = rating_order.get(min_rating, 0)

    # Apply filters
    filtered_games = games_df[
        (games_df['positive_ratio'] >= min_positive_ratio) &
        (games_df['user_reviews'] >= min_user_reviews) &
        (games_df['rating_value'] >= min_rating_value) &
        (games_df['date_release'].dt.year >= earliest_release_year)
    ]

    # Drop the temporary 'rating_value' column
    filtered_games = filtered_games.drop(columns=['rating_value'])

    return filtered_games

# Ensure date_release is a datetime object
games_complete_df['date_release'] = pd.to_datetime(games_complete_df['date_release'], errors='coerce')

filtered_games_csv = filter_games(
    games_complete_df,
    min_positive_ratio=70,
    min_user_reviews=50,
    min_rating='Mixed',
    earliest_release_year=1990
)

# Assuming 'combined_df' includes data from 'games_csv' and 'games_metadata'
# Filter 'combined_df' to include only the filtered games
combined_df = combined_df[combined_df['app_id'].isin(filtered_games_csv['app_id'])]

# Session storage (can be replaced by a database if needed)
user_sessions = {}

class UserSession:
    """Tracks user preferences, liked and disliked games, excluded tags, user ID, and reminders."""

    def __init__(self):
        self.liked_games = set()  # Store liked games
        self.disliked_games = set()  # Store disliked games
        self.excluded_tags = set()  # Store excluded tags (e.g., genres or themes)
        self.user_preferences = {}  # General user preferences (can store anything)
        self.user_id = None  # Store the user's Telegram ID
        self.reminders = []  # Store reminders set by the user

    def update_likes(self, games):
        """Add games to the liked list."""
        self.liked_games.update(games)

    def update_dislikes(self, games):
        """Add games to the disliked list."""
        self.disliked_games.update(games)

    def set_user_id(self, user_id):
        """Set the user ID from Telegram."""
        self.user_id = user_id

    def update_preferences(self, preferences):
        """Update user preferences (e.g., if they like certain game genres)."""
        self.user_preferences.update(preferences)

    def set_excluded_tags(self, tags):
        """Set tags the user wants to exclude from recommendations."""
        self.excluded_tags.update(tags)

    def get_excluded_tags(self):
        """Retrieve the tags the user has excluded."""
        return self.excluded_tags

    def add_reminder(self, reminder):
        """Add a reminder to the user's session."""
        self.reminders.append(reminder)

    def get_reminders(self):
        """Get all reminders set by the user."""
        return self.reminders

# Function to retrieve or create a session for a given user ID
def get_user_session(user_id):
    """Retrieve or create a new user session based on the Telegram user ID."""
    if user_id not in user_sessions:
        user_sessions[user_id] = UserSession()
    return user_sessions[user_id]





from googletrans import Translator
import logging

# Initialize the translator
translator = Translator()

def detect_language(text):
    """
    Detect the language of the given text.
    """
    detection = translator.detect(text)
    return detection.lang

def translate_to_english(text):
    """
    Translate the given text to English.
    """
    translation = translator.translate(text, dest='en')
    return translation.text

def translate_from_english(text, dest_language):
    """
    Translate English text to the specified destination language.
    """
    translation = translator.translate(text, dest=dest_language)
    return translation.text

def handle_translation(update: Update, user_message: str, session) -> tuple:
    """
    Translate the user message to English if necessary and return the translated message.
    """
    try:
        detected_language = detect_language(user_message)

        # If the message is already in English, return it directly
        if detected_language == 'en':
            return user_message, 'en'

        # Translate the message to English if it is in another language
        translated_text = translate_to_english(user_message)
        return translated_text, detected_language
    except Exception as e:
        logging.error(f"Translation error: {e}")
        update.message.reply_text("An error occurred while translating your message.")
        return None, None  # In case of failure, return None

def extract_steam_id(user_message):
    match = re.search(r'\b(\d{5,})\b', user_message)
    return int(match.group(1)) if match else None

def store_steam_id(user_message, session):
    match = re.search(r'\b(\d{5,})\b', user_message)
    if match:
        session.user_id = int(match.group(1))
        return f"Thanks for providing your Steam ID ({session.user_id}). I'll use this to personalize recommendations!"
    return None

# def top_games_by_category(games_df, genre, top_n=5):
#     filtered_games = games_complete_df[games_complete_df['genres'].str.contains(genre, case=False, na=False)]
#     sorted_games = filtered_games.sort_values(by=['positive_ratio', 'user_reviews'], ascending=False).head(top_n)

#     if sorted_games.empty:
#         return f"Sorry, I couldn't find any top-rated games in the {genre} category."

#     response = f"Top-rated {genre} games:\n"
#     for i, row in sorted_games.iterrows():
#         response += f"{row['title']} - Rating: {row['rating']} ({row['positive_ratio']}% positive reviews)\n"
#     return response

from datetime import datetime
def fetch_steam_profile(steam_id):
    """Fetches the Steam profile information for a given Steam ID."""
    api_key = os.getenv('STEAM_API_KEY')  # Ensure you have set the STEAM_API_KEY environment variable
    if not api_key:
        raise ValueError("Steam API key not found. Please set the STEAM_API_KEY environment variable.")

    url = f"http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key={api_key}&steamid={steam_id}&include_appinfo=1&format=json"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    else:
        logging.error(f"Steam API error: {response.status_code}")
        return None

def analyze_profile(profile_data):
    """Analyze the user's Steam profile data and return a summary."""
    games = profile_data.get('response', {}).get('games', [])
    if not games:
        return "No games found in your Steam profile."

    # Calculate total playtime in hours
    total_playtime = sum(game.get('playtime_forever', 0) for game in games) // 60

    # Get the most played games
    most_played_games = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)[:5]

    # Get game IDs
    game_ids = [game['appid'] for game in most_played_games]

    # Get game details from your games DataFrame
    game_details = games_complete_df[games_complete_df['app_id'].isin(game_ids)]

    # Extract genres
    genre_list = []
    for game in game_details.itertuples():
        genres = game.genres
        if isinstance(genres, list):
            genre_list.extend(genres)
        elif isinstance(genres, str):
            genre_list.extend(genres.split(','))

    genre_counts = pd.Series(genre_list).value_counts()
    favorite_genres = genre_counts.head(3).index.tolist()

    # Prepare the profile summary as a dictionary
    profile_summary = {
        'total_playtime': total_playtime,  # Total playtime in hours
        'most_played_games': [],
        'favorite_genres': favorite_genres
    }

    # Prepare the most played games list with playtime in hours
    for game in most_played_games:
        app_id = game['appid']
        playtime_hours = game.get('playtime_forever', 0) // 60
        title_row = game_details[game_details['app_id'] == app_id]
        if not title_row.empty:
            title = title_row.iloc[0]['title']
            profile_summary['most_played_games'].append(f"{title} ({playtime_hours} hours)")
        else:
            profile_summary['most_played_games'].append(f"Unknown Game (AppID: {app_id}) ({playtime_hours} hours)")

    return profile_summary

api_key = os.getenv('STEAM_API_KEY')

def get_request(url, parameters=None):
    """Helper function to handle HTTP GET requests."""
    response = requests.get(url, params=parameters)
    return response.json()

def parse_steam_price_request(appid):
    """Fetches the current price for a Steam game using the Steam Store API."""
    url = "http://store.steampowered.com/api/appdetails/"
    parameters = {"appids": appid}
    json_data = get_request(url, parameters)

    if str(appid) in json_data and json_data[str(appid)]['success']:
        data = json_data[str(appid)]['data']

        if 'price_overview' in data and data['price_overview']:
            price_info = data['price_overview']
            current_price_cents = price_info.get('final', 0)  # Price in cents
            original_price_cents = price_info.get('initial', 0)  # Price in cents
            discount = price_info.get('discount_percent', 'No discount')
            currency = price_info.get('currency', 'EUR')
        else:
            current_price_cents = original_price_cents = 0
            discount = 'Price data unavailable'
            currency = 'EUR'  # Default currency if not available
    else:
        current_price_cents = original_price_cents = 0
        discount = 'Price data unavailable'
        currency = 'EUR'

    # Convert price from cents to currency units (do not convert to USD)
    current_price = current_price_cents / 100
    original_price = original_price_cents / 100

    # No exchange rate conversion, keep the currency as is
    current_price = round(current_price, 2)
    original_price = round(original_price, 2)

    return {
        'appid': appid,
        'current_price': current_price,
        'original_price': original_price,
        'discount_percent': discount,
        'currency': currency,
        'date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }



def parse_price(price_str):
    """
    Parse the price string and convert it to a float.
    Handles European style prices (e.g., '19,99€' or '19.99€').
    """
    # Remove non-numeric characters except for comma and dot (currency symbols and spaces)
    price_str = re.sub(r'[^\d,\.]', '', price_str)

    # Replace comma with a dot (e.g., '19,99' becomes '19.99')
    price_str = price_str.replace(',', '.')

    try:
        # Convert to float after cleaning
        return float(price_str)
    except ValueError:
        print(f"Error parsing price: {price_str}")
        return None  # Return None if parsing fails

def save_price_data_to_csv(data, filename='../data/price_history.csv'):
    """Save the price data to a CSV file, appending to it if it exists."""
    # Ensure the directory exists
    directory = os.path.dirname(filename)
    if not os.path.exists(directory):
        os.makedirs(directory)

    # Convert the data to a DataFrame
    df = pd.DataFrame([data])

    # Check if the file exists
    try:
        existing_df = pd.read_csv(filename)
        # Append the new data
        updated_df = pd.concat([existing_df, df], ignore_index=True)
        updated_df.to_csv(filename, index=False)
    except FileNotFoundError:
        # If the file doesn't exist, create it with headers
        df.to_csv(filename, index=False)

def track_price_changes(app_list, download_path='../data', filename='price_history.csv'):
    """Track price changes for a list of Steam apps and store them in a CSV."""
    price_data_list = []
    for appid in app_list:
        # Fetch the current price data
        price_data = parse_steam_price_request(appid)

        # Save the price data to CSV
        save_price_data_to_csv(price_data, filename=f"{download_path}/{filename}")

        print(f"Price for app {appid} tracked at {price_data['date']}: {price_data['current_price']}")

        # Append the price data to the list
        price_data_list.append(price_data)

    return price_data_list

def handle_price_tracker(update: Update, context: CallbackContext) -> None:
    """Handle the '/price' command, where the user provides game titles to track."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    global games_complete_df  # Ensure we have access to games_complete_df

    # Extract game titles from the user's message
    game_titles = extract_game_titles(user_message)

    if not game_titles:
        update.message.reply_text("I couldn't find any valid game titles in your message. Please provide game titles.")
        return

    # Match game titles with app IDs from the DataFrame
    app_ids = match_titles_to_app_ids(game_titles, games_complete_df)

    if not app_ids:
        update.message.reply_text("I couldn't find any matching games in my database.")
        return

    # Call the track_price_changes function with the matched app IDs
    try:
        # Get the price data for the apps
        price_data_list = track_price_changes(app_ids)  # Now returns price data

        # Prepare the response message
        response_lines = []
        for game_title, price_data in zip(game_titles, price_data_list):
            current_price = price_data.get('current_price', 'N/A')
            original_price = price_data.get('original_price', 'N/A')
            currency = price_data.get('currency', '')
            # Format the prices appropriately
            if current_price == 'N/A':
                price_line = f"{game_title}: Price information is not available."
            else:
                if current_price == 0:  # Free game
                    price_line = f"{game_title}: Free to Play"
                else:
                    # No need to divide by 100 here since it's already done in parse_steam_price_request
                    price_line = f"{game_title}: Current Price - {current_price:.2f} {currency}, Original Price - {original_price:.2f} {currency}"
            response_lines.append(price_line)

        response_message = "I'm now tracking the prices for the following games:\n\n" + "\n".join(response_lines) + "\n\nI'll let you know about any changes."

        # Send the response message
        update.message.reply_text(response_message)
    except Exception as e:
        update.message.reply_text(f"An error occurred while tracking the prices: {str(e)}")





def match_titles_to_app_ids(titles, games_complete_df):
    """Match provided game titles with app IDs from the games_complete_df."""
    app_ids = []

    # Ensure the 'title' column is treated as a string (in case it's not)
    games_complete_df['title'] = games_complete_df['title'].astype(str)

    for title in titles:
        # Normalize both the title and the DataFrame column for case-insensitive matching
        match = games_complete_df[games_complete_df['title'].str.contains(title, case=False, na=False)]

        if not match.empty:
            # Assuming there is only one match per title (you can handle multiple matches as needed)
            app_ids.append(match.iloc[0]['app_id'])

    return app_ids

# youtube

def extract_video_type(user_message):
    video_types = ['trailer', 'gameplay', 'review', 'walkthrough', 'guide', 'preview', 'cutscene', 'speedrun']
    for video_type in video_types:
        if video_type in user_message.lower():
            return video_type
    return None  # Default if no specific type is mentioned

def handle_video_search(update: Update, context: CallbackContext) -> None:
    """Handle the '/video' command to search for game videos or trailers."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    # Extract game titles from the user's message
    game_titles = extract_game_titles(user_message)
    if game_titles:
        game_title = game_titles[0]
        video_type = extract_video_type(user_message)

        # Construct the search query
        if video_type:
            search_query = f"{game_title} {video_type}"
        else:
            search_query = game_title  # General search for the game

        video_info = search_youtube_videos(search_query, max_results=1)
        if video_info:
            video_description = f"{video_type.capitalize()}" if video_type else "Video"
            update.message.reply_text(f"Here's a {video_description} for '{game_title}':\n{video_info['url']}")
        else:
            video_description = video_type or 'video'
            response = generate_custom_response(f"Sorry, I couldn't find a {video_description} for '{game_title}'.")
            update.message.reply_text(response)
    else:
        response = generate_custom_response("Please specify the game you'd like to see a video for.")
        update.message.reply_text(response)



def search_youtube_videos(query, max_results=1):
    api_key = os.getenv('YOUTUBE_API_KEY')  # Ensure you have set the YOUTUBE_API_KEY environment variable
    if not api_key:
        raise ValueError("YouTube API key not found. Please set the YOUTUBE_API_KEY environment variable.")

    # Refine the query for more specific video types (e.g., walkthrough, gameplay)
    refined_query = query + " walkthrough full playthrough guide"  # Add walkthrough-related terms to the search query

    try:
        youtube = build('youtube', 'v3', developerKey=api_key)
        request = youtube.search().list(
            part='snippet',
            q=refined_query,
            maxResults=max_results,
            type='video',
            videoEmbeddable='true',
            videoSyndicated='true',
            safeSearch='moderate',
            order='relevance'  # Change order to 'relevance' to prioritize more relevant videos
        )
        response = request.execute()

        if response['items']:
            # Extract relevant details from the top result
            item = response['items'][0]
            video_id = item['id']['videoId']
            title = item['snippet']['title']
            description = item['snippet']['description']
            url = f'https://www.youtube.com/watch?v={video_id}'

            # If you want to ensure the result is a long video, you can add a length check
            # YouTube provides duration in ISO 8601 format. For example, PT1H30M means 1 hour and 30 minutes.
            # We can convert it to a total minute count to compare it with a minimum threshold for walkthroughs.
            video_details = youtube.videos().list(
                part="contentDetails",
                id=video_id
            ).execute()

            duration = video_details['items'][0]['contentDetails']['duration']  # Duration in ISO 8601 format
            minutes = parse_duration(duration)  # Function to convert ISO duration to minutes

            # Example: If it's under 10 minutes, we may skip it for walkthrough searches
            if minutes < 10:
                return {'title': f"Short video found: {title}", 'url': url}

            return {'title': title, 'url': url}
        else:
            return None
    except HttpError as e:
        logging.error(f"YouTube API error: {e}")
        return None


def parse_duration(duration):
    """
    Parse the ISO 8601 duration format (e.g., PT1H30M) into total minutes.
    """
    import re
    time_parts = re.findall(r'(\d+)([HMS])', duration)
    total_minutes = 0
    for value, unit in time_parts:
        value = int(value)
        if unit == 'H':
            total_minutes += value * 60  # Convert hours to minutes
        elif unit == 'M':
            total_minutes += value  # Minutes
        elif unit == 'S':
            total_minutes += value / 60  # Convert seconds to minutes (if needed)
    return total_minutes

def handle_opinion_request(update: Update, context: CallbackContext) -> None:
    """Handle the '/opinion' command to provide an opinion on a game."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    global games_complete_df

    game_titles = extract_game_titles(user_message)
    if game_titles:
        game_title = game_titles[0]
        game_info = get_game_info_by_title(game_title, games_complete_df)

        if game_info.empty:
            update.message.reply_text(f"Sorry, I couldn't find information on '{game_title}'.")
        else:
            opinion = generate_game_opinion(game_info)
            response = generate_custom_response(opinion)
            update.message.reply_text(response)
    else:
        response = generate_custom_response("Please specify the game you'd like my opinion on.")
        update.message.reply_text(response)



def generate_game_opinion(game_info):
    # Check if game_info is a pandas Series
    if isinstance(game_info, pd.Series):
        # Extract the necessary fields safely
        title = game_info.get('title', pd.NA)
        description = game_info.get('about_game', pd.NA)  # Changed from 'description' to 'about_game'
        genres = game_info.get('genres', pd.NA)
        rating = game_info.get('rating', pd.NA)
        release_date = game_info.get('date_release', pd.NA)
        positive_ratio = game_info.get('positive_ratio', pd.NA)
        user_reviews = game_info.get('user_reviews', pd.NA)

        # Check if critical fields are missing or NA
        # Ensure genres is treated properly, especially if it's a list or array
        if pd.isna(title) or (isinstance(genres, (list, pd.Series)) and all(pd.isna(genres))):
            return "Sorry, I couldn't retrieve enough information for this game."

        # Generate a prompt for the language model
        prompt = f"""<s>[INST] Provide a brief opinion on the game '{title}'.

Game Information:
Title: {title}
Genres: {genres}
Rating: {rating}
Release Date: {release_date}
Positive Reviews: {positive_ratio}%
Total Reviews: {user_reviews}

Description: {description}

Please provide a balanced opinion about this game, discussing its main features, strengths, and any notable aspects.[/INST]"""

        # Tokenize the input
        inputs = tokenizer(prompt, return_tensors="pt").to(device)

        # Generate the opinion using the model
        response = model.generate(
            **inputs,
            max_new_tokens=300,
            do_sample=True,
            temperature=0.7,
            top_p=0.9,
            repetition_penalty=1.2,
            pad_token_id=tokenizer.pad_token_id
        )

        # Decode the response and clean it up
        result = tokenizer.decode(response[0], skip_special_tokens=True).strip()

        # Improved cleaning pattern
        patterns = [
            r'\[INST\].*?\[/INST\]',  # Remove INST tags and content
            r'<s>|</s>',  # Remove start/end tokens
            r'You are having.*?Reply to:.*?(?=\w)',  # Remove instruction text
            r'^\s*[-•]\s*',  # Remove any bullet points
            r'\n\s*\n',  # Remove multiple newlines
        ]

        cleaned_response = result
        for pattern in patterns:
            cleaned_response = re.sub(pattern, '', cleaned_response, flags=re.DOTALL|re.IGNORECASE).strip()

        # Final cleanup of extra spaces
        cleaned_response = re.sub(r'\s+', ' ', cleaned_response).strip()

        return cleaned_response or "I couldn't generate an opinion for this game."
    else:
        return "Sorry, I couldn't retrieve enough information for this game."

def handle_user_gaming_profile(user_message, session):
    if session.user_id:
        profile_data = fetch_steam_profile(session.user_id)
        if profile_data:
            profile_summary = analyze_profile(profile_data)
            return generate_custom_response(profile_summary)
        else:
            return generate_custom_response("I couldn't retrieve your Steam profile data. Please ensure your Steam profile is public and try again.")
    else:
        return generate_custom_response("Please provide your Steam ID to analyze your gaming profile.")

def handle_top_games_request(update: Update, context: CallbackContext) -> None:
    """
    Handles a request for top games of a specified genre based on user preferences.
    """
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    global games_complete_df

    # Infer genres from the user's message using LLM
    user_preferences = infer_user_preferences_with_llm(user_message)
    genres = user_preferences.get('genres', [])

    if genres:
        # Use the first genre and normalize to lower case
        genre = genres[0].strip().lower()

        # Get the top games
        top_games = top_games_by_category(games_complete_df, genre, top_n=10)
        if top_games.empty:
            response = generate_custom_response(f"Sorry, I couldn't find any top games in the genre '{genre}'.")
            update.message.reply_text(response)
            return

        # Format the response
        top_games_list = "\n\n".join([
            f"{i}. *{row.title}*\nRating: {row.rating}, Positive Reviews: {row.positive_reviews:.0f}%"
            for i, row in enumerate(top_games.itertuples(), 1)
        ])

        response = f"Top 10 {genre.capitalize()} games:\n\n{top_games_list}"

        # Send the response with Markdown formatting
        update.message.reply_text(response, parse_mode='Markdown')
    else:
        response = generate_custom_response("Please specify the genre you're interested in.")
        update.message.reply_text(response)





def top_games_by_category(games_df, genre, top_n=10):
    """
    Filters and sorts games by a specified genre and returns the top N games.
    """
    # Make sure genre is a string and handle case-insensitivity
    genre = genre.strip().lower()

    # Filter games by genre, ensuring case-insensitive matching
    filtered_games = games_df[games_df['genres'].apply(lambda x: isinstance(x, list) and genre in [g.lower() for g in x])].copy()

    if filtered_games.empty:
        return f"Sorry, I couldn't find any top-rated games in the {genre} category. Please try searching for a different genre or filtering your search by other criteria such as platform or rating."

    # Rating mapping to score games
    rating_order = {
        'Overwhelmingly Positive': 5,
        'Very Positive': 4,
        'Positive': 3,
        'Mostly Positive': 2,
        'Mixed': 1,
        'Mostly Negative': -1,
        'Negative': -2,
        'Very Negative': -3,
        'Overwhelmingly Negative': -4
    }

    # Make sure ratings and other important columns are in expected format
    filtered_games.loc[:, 'rating_value'] = filtered_games['rating'].map(rating_order).fillna(0)
    filtered_games.loc[:, 'positive_ratio'] = filtered_games['positive_ratio'].fillna(0)
    filtered_games.loc[:, 'user_reviews'] = filtered_games['user_reviews'].fillna(0)

    # Calculate a score for sorting games
    filtered_games.loc[:, 'score'] = (
        filtered_games['rating_value'] * 2 +
        filtered_games['positive_ratio'] * 0.1 +
        np.log1p(filtered_games['user_reviews'])
    )

    # Sort by the calculated score and select top N games
    top_games = filtered_games.sort_values(by='score', ascending=False).head(top_n)

    # Prepare the response to return top N games
    response = f"Top {top_n} {genre} games:\n"
    for idx, row in top_games.iterrows():
        response += f"- {row['title']} (Rating: {row['rating']}, Positive Reviews: {row['positive_ratio']}%)\n"

    return response.strip()

# reminder

def extract_date_time(user_message):
    # Use dateparser to handle more flexible time expressions like "prime time"
    parsed_date = dateparser.parse(user_message, settings={'PREFER_DATES_FROM': 'future'})

    # Handle the "prime time" and "every evening" cases
    if "prime time" in user_message.lower():
        # If "prime time" is mentioned, we can assume a standard time like 9:00 PM
        if not parsed_date:
            parsed_date = dateparser.parse("9:00 PM")  # Default to 9:00 PM if no time is parsed
    if "every evening" in user_message.lower() and parsed_date:
        # Modify parsed date to reflect the recurring "every evening"
        parsed_date = parsed_date.replace(hour=21, minute=0)  # 9:00 PM, every evening

    if parsed_date:
        return parsed_date.strftime('%Y-%m-%d %H:%M')  # Return time in a standard format
    else:
        return None



# Function to extract reminder time from the message
def extract_reminder_time(user_message):
    """
    Extract the reminder time from the user's message using dateparser.
    """
    parsed_date = dateparser.parse(user_message, settings={'PREFER_DATES_FROM': 'future'})
    if parsed_date:
        return parsed_date.strftime('%Y-%m-%d %H:%M')
    else:
        return None

def handle_game_session_reminder(update: Update, context: CallbackContext) -> None:
    """Handle the '/reminder' command to set a game session reminder."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    # Extract game titles and reminder time from the user's message
    game_titles = extract_game_titles(user_message)  # May be empty
    reminder_time = extract_date_time(user_message)  # Handle phrases like "tomorrow at 7 PM"

    if reminder_time:
        # If no game is specified, ask for one or use a default title
        if not game_titles:
            update.message.reply_text("Please specify the game you'd like me to remind you to play at this time.")
            return

        # Store the reminder in the session
        reminder = {'game': game_titles[0], 'time': reminder_time}
        session.reminders.append(reminder)

        update.message.reply_text(f"Reminder set to play '{game_titles[0]}' at {reminder_time}.")
    else:
        update.message.reply_text("Please specify the time you'd like me to remind you.")



# ======== Filtering and Recommendation Functions =========

import re

def infer_user_preferences_with_llm(user_message):
    """
    Infers user preferences such as liked games, disliked games, genres, release year filter, and excluded tags
    from user message.
    """
    # Enhanced prompt to accurately infer user preferences
    prompt = f"""[INST] Extract the user's game preferences from this message.

1. LIKED GAMES: List all games the user likes, mentioned with words like 'love', 'enjoy', 'like', etc. If no games are mentioned, leave the list empty.
2. GENRES: List all genres the user mentions liking, such as 'RPG', 'Action', 'Adventure', etc. If no genres are mentioned, leave the list empty.
3. EXCLUDED TAGS: List any genres or elements the user dislikes, such as 'horror', 'violence', 'mature'. If no exclusions are mentioned, leave the list empty.

Message: "{user_message}"

Output only the preferences in this exact format, with the fields filled in:
{{
  "liked_games": [list of liked games or empty list],
  "genres": [list of liked genres or empty list],
  "excluded_tags": [list of excluded tags or empty list]
}}[/INST]"""

    try:
        # Extract user preferences from the model
        inputs = tokenizer(prompt, return_tensors="pt", padding=True, truncation=True, max_length=300)
        inputs = {key: value.to(model.device) for key, value in inputs.items()}

        response = model.generate(
            **inputs,
            max_new_tokens=150,
            do_sample=True,
            temperature=0.2,
            pad_token_id=tokenizer.pad_token_id
        )
        result_text = tokenizer.decode(response[0], skip_special_tokens=True).strip()

        # Helper function to clean and parse list-like strings
        def clean_text(text):
            if not text:
                return []
            text = text.strip("[]")
            return [item.strip('" ').strip("'") for item in text.split(",") if item.strip('" ').strip("'")]

        # Default preferences structure
        preferences = {
            "liked_games": [],
            "genres": [],
            "release_year_filter": None,
            "excluded_tags": []
        }

        # Parse each section if it exists
        sections = {
            "Liked Games": "liked_games",
            "Genres": "genres",
            "Excluded Tags": "excluded_tags"
        }

        for section_name, pref_key in sections.items():
            pattern = f"{section_name}:\\s*\\[(.*?)\\]"
            match = re.search(pattern, result_text, re.IGNORECASE | re.DOTALL)
            if match:
                cleaned_values = clean_text(match.group(1))
                preferences[pref_key] = cleaned_values

        # Explicitly check for common mature content exclusions
        exclusion_keywords = ['violence', 'blood', 'gore', 'mature', 'explicit', 'adult']
        for keyword in exclusion_keywords:
            if keyword in user_message.lower():
                preferences["excluded_tags"].append(keyword.capitalize())  # Adding the tag to exclusions

        # Handle explicitly liked games (e.g., Skyrim, Witcher 3)
        if "love" in user_message.lower() or "enjoy" in user_message.lower() or "like" in user_message.lower():
            liked_games = extract_game_titles(user_message)
            preferences["liked_games"].extend(liked_games)

        # Handle genres (RPG, Action)
        inferred_genres = infer_genres_from_message(user_message)
        preferences["genres"].extend(inferred_genres)

        # Return the final preferences
        return preferences

    except Exception as e:
        print(f"Error in preference inference: {e}")
        # Fallback to basic game title extraction if the LLM model fails
        game_titles = extract_game_titles(user_message)
        return {
            "liked_games": game_titles,
            "disliked_games": [],
            "genres": [],
            "release_year_filter": None,
            "excluded_tags": []
        }

# Helper function to infer genres based on the context of the user message
def infer_genres_from_message(user_message):
    # Define common genre-related keywords
    genre_keywords = {
        "RPG": ["role-playing", "RPG", "story-driven", "quests", "adventure"],
        "Action": ["action", "combat", "fast-paced", "exploration"],
        "Adventure": ["adventure", "open-world", "exploration", "story-driven"],
        "Horror": ["horror", "scary", "survival", "thriller", "creepy"],
        "Strategy": ["strategy", "tactics", "turn-based", "real-time", "management"],
        "Simulation": ["simulation", "life-simulation", "building", "management"],
        "Shooter": ["shooter", "FPS", "first-person", "third-person", "gunplay"],
        "Sports": ["sports", "soccer", "basketball", "racing", "competitive"],
        "Fighting": ["fighting", "brawler", "combat", "melee"],
        "Puzzle": ["puzzle", "brain-teaser", "logic", "platformer"]
    }

    # Lowercase the message for case-insensitive matching
    lower_message = user_message.lower()

    # Check for genre keywords in the message
    inferred_genres = []
    for genre, keywords in genre_keywords.items():
        for keyword in keywords:
            if keyword in lower_message:
                inferred_genres.append(genre)
                break  # Stop after the first match for that genre

    return inferred_genres

def extract_steam_id(user_message):
    match = re.search(r'\b(\d{5,})\b', user_message)
    return int(match.group(1)) if match else None

AAA_STUDIOS = [
    "Ubisoft", "Electronic Arts", "Rockstar Games", "Activision", "Square Enix",
    "Bethesda", "Sony Interactive Entertainment", "Microsoft Studios", "Capcom",
    "Bandai Namco", "Warner Bros", "Take-Two Interactive", "CD Projekt Red",
    "SEGA", "Blizzard Entertainment", "Konami", "2K Games", "THQ Nordic",
    "Nintendo", "Insomniac Games", "Bungie", "Respawn Entertainment",
    "Monolith Productions", "IO Interactive", "Crystal Dynamics", "Bioware",
    "Naughty Dog", "Sucker Punch Productions", "Guerrilla Games", "FromSoftware",
    "Gearbox Software", "Treyarch", "Infinity Ward", "id Software", "Valve",
    "Epic Games", "DICE", "Creative Assembly", "Relic Entertainment",
    "Obsidian Entertainment", "Remedy Entertainment", "Arkane Studios",
    "Avalanche Studios", "Rocksteady Studios", "MachineGames", "Firaxis Games",
    "Eidos Montreal", "People Can Fly", "Neversoft", "Santa Monica Studio",
    "Bluepoint Games", "Digital Extremes", "Media Molecule", "Polyphony Digital",
    "Kojima Productions", "PlatinumGames", "Mojang Studios", "Crytek",
    "ZeniMax Online Studios", "Volition", "Rebellion Developments", "BioWare",
    "Feral Interactive", "Behaviour Interactive", "Square Enix Montreal",
    "id Software", "Nixxes Software",
    # Additional notable AAA studios:
    "Tencent Interactive Entertainment", "NetEase Games", "Embracer Group",
    "MiHoYo", "Roblox Corporation", "Playtika", "Nexon", "37Games",
    "Oculus Studios", "Netmarble", "NCSoft", "Playrix", "Krafton",
    "Perfect World", "Garena", "NetDragon Websoft", "Smilegate",
    "Wizards of the Coast", "Scopely", "Capcom", "Dream Games",
    "Keywords Studios", "Moon Active", "Kakao Games", "Niantic",
    "LilithGames", "FunPlus", "Xflag", "Koei Tecmo", "Gameloft",
    "CD Projekt Red", "Playstudios", "Tilting Point", "Thunderful Group",
    "Pearl Abyss", "Neowiz Games", "Paradox Interactive", "Marvelous",
    "Enad Global 7", "Focus Entertainment", "Nacon", "Behaviour Interactive",
    "Saber Interactive", "Team17", "FromSoftware", "Devolver Digital",
    "Digital Bros", "Frontier Developments",
    # Newly added studios and subsidiaries:
    "Lightspeed LA", "Bad Brain Game Studios", "PinCool", "T-Minus Zero Entertainment",
    "Fantastic Pixel Castle", "Worlds Untold", "BulletFarm", "That's No Moon"
]



# Helper function to classify studio type based on known AAA studios
def classify_studio_type(developer_name):
    """Classify a game as AAA or Indie based on the developer name."""
    if any(aaa_studio in developer_name for aaa_studio in AAA_STUDIOS):
        return 'AAA'
    return 'Indie'  # Default to Indie for unrecognized studios

def content_based_filtering(user_preferences, games_df):
    filtered_df = games_df.copy()

    # Apply genre inclusion filters if present
    include_genres = user_preferences.get("include_genres", [])
    if include_genres and 'tags' in filtered_df.columns:
        filtered_df = filtered_df[filtered_df['tags'].apply(
            lambda tags: any(tag.lower() in (t.lower() for t in tags) for tag in include_genres)
        )]

    # Apply genre exclusion filters if present
    exclude_genres = user_preferences.get("exclude_genres", [])
    if exclude_genres and 'tags' in filtered_df.columns:
        filtered_df = filtered_df[~filtered_df['tags'].apply(
            lambda tags: any(tag.lower() in (t.lower() for t in tags) for tag in exclude_genres)
        )]

    # Apply developer type filter based on AAA/Indie classification
    developer_type = user_preferences.get("developer_type")
    if developer_type and 'developer' in filtered_df.columns:
        filtered_df['studio_type'] = filtered_df['developer'].apply(classify_studio_type)
        filtered_df = filtered_df[filtered_df['studio_type'] == developer_type]

    # Apply price filters if present
    min_price = user_preferences.get("min_price")
    max_price = user_preferences.get("max_price")
    if min_price or max_price:
        if 'price_final' in filtered_df.columns:
            if min_price:
                filtered_df = filtered_df[filtered_df['price_final'] >= min_price]
            if max_price:
                filtered_df = filtered_df[filtered_df['price_final'] <= max_price]

    # Apply platform filters (e.g., Windows, Mac, Linux)
    platforms = user_preferences.get("platforms", [])
    if platforms:
        platform_columns = {'win': 'Windows', 'mac': 'Mac', 'linux': 'Linux', 'steam_deck': 'Steam Deck'}
        supported_platforms = [platform_columns[platform] for platform in platforms if platform in platform_columns]
        if supported_platforms:
            filtered_df = filtered_df[filtered_df[supported_platforms].any(axis=1)]

    # Apply rating filters
    min_rating = user_preferences.get("min_rating")
    max_rating = user_preferences.get("max_rating")
    if min_rating or max_rating:
        if 'rating' in filtered_df.columns:
            if min_rating:
                filtered_df = filtered_df[filtered_df['rating'] >= min_rating]
            if max_rating:
                filtered_df = filtered_df[filtered_df['rating'] <= max_rating]

    # Apply user reviews filter
    min_user_reviews = user_preferences.get("min_user_reviews")
    if min_user_reviews and 'user_reviews' in filtered_df.columns:
        filtered_df = filtered_df[filtered_df['user_reviews'] >= min_user_reviews]

    # Apply release year filters if date_release column exists
    if 'date_release' in filtered_df.columns:
        filtered_df['date_release'] = pd.to_datetime(filtered_df['date_release'], errors='coerce')
        start_year = user_preferences.get("start_year")
        end_year = user_preferences.get("end_year")

        if start_year:
            filtered_df = filtered_df[filtered_df['date_release'].dt.year >= start_year]
        if end_year:
            filtered_df = filtered_df[filtered_df['date_release'].dt.year <= end_year]

    # Apply playtime filters (average playtime)
    min_playtime = user_preferences.get("min_playtime")
    if min_playtime and 'average_playtime_forever' in filtered_df.columns:
        filtered_df = filtered_df[filtered_df['average_playtime_forever'] >= min_playtime]

    return filtered_df.drop(columns=['studio_type'], errors='ignore')  # Drop the temporary 'studio_type' column after filtering

def compare_games(game1_info, game2_info):
    # Ensure that the input is a pandas Series (each game data should be a single row from the DataFrame)
    if not isinstance(game1_info, pd.Series) or game1_info.empty:
        return "Error: Unable to find information for the first game."
    if not isinstance(game2_info, pd.Series) or game2_info.empty:
        return "Error: Unable to find information for the second game."

    # Extract relevant details from the Series (each representing a single game)
    game1_title = game1_info['title']
    game2_title = game2_info['title']

    # Prepare comparison details
    comparison_result = f"**Comparison between '{game1_title}' and '{game2_title}':**\n\n"

    # Genres (join list items if genres are in a list format)
    game1_genres = ', '.join(game1_info['genres']) if isinstance(game1_info['genres'], list) else game1_info['genres']
    game2_genres = ', '.join(game2_info['genres']) if isinstance(game2_info['genres'], list) else game2_info['genres']
    comparison_result += f"- **Genres:**\n  - {game1_title}: {game1_genres}\n  - {game2_title}: {game2_genres}\n\n"

    # Ratings (adjusted column name)
    game1_rating = game1_info['rating']  # Assuming 'rating' exists in your dataset
    game2_rating = game2_info['rating']
    comparison_result += f"- **Ratings:**\n  - {game1_title}: {game1_rating}\n  - {game2_title}: {game2_rating}\n\n"

    # Release Dates (adjusted column name)
    game1_release = game1_info['release_date']  # Assuming 'release_date' exists in your dataset
    game2_release = game2_info['release_date']
    comparison_result += f"- **Release Dates:**\n  - {game1_title}: {game1_release}\n  - {game2_title}: {game2_release}\n\n"

    # Descriptions (truncate to 500 characters)
    game1_description = game1_info['description'][:500] if isinstance(game1_info['description'], str) else 'No description available'
    game2_description = game2_info['description'][:500] if isinstance(game2_info['description'], str) else 'No description available'
    comparison_result += f"- **Descriptions:**\n  - {game1_title}: {game1_description}\n  - {game2_title}: {game2_description}\n\n"

    return comparison_result

def get_game_info_by_title(game_title, games_df):
    # Normalize the game title for case-insensitive matching
    game_title_normalized = game_title.lower()

    # Create a list of all game titles in the dataset, normalized
    game_titles_normalized = games_complete_df['title'].str.lower().tolist()

    # Use fuzzy matching to find the closest game title in the dataset
    match = process.extractOne(game_title_normalized, game_titles_normalized, scorer=fuzz.token_sort_ratio)

    if match and match[1] > 80:  # Only accept matches with a high similarity score
        matched_title = games_complete_df.iloc[game_titles_normalized.index(match[0])]
        return matched_title
    else:
        # No good match found
        return pd.DataFrame()

def collaborative_filtering_with_fallback(user_id, filtered_games, session, game_titles=None, top_n=5):
    """
    Provides game recommendations using collaborative filtering, with fallback to content-based recommendations if needed.
    """
    recommendations = pd.DataFrame()  # Start with an empty dataframe for recommendations

    # Try collaborative filtering if user_id is provided
    if user_id:
        # Encode user_id for embeddings
        try:
            user_id_encoded = user_encoder.transform([user_id])
            user_embedding = ncf_model.get_layer('user_embedding')(user_id_encoded).numpy()
        except Exception as e:
            print(f"Error encoding user ID {user_id}: {e}")
            user_embedding = None
    else:
        # Fallback to liked games embeddings if no user_id
        liked_app_ids = get_app_ids_by_fuzzy_matching(game_titles, filtered_games)
        if liked_app_ids:
            try:
                game_ids_encoded = game_encoder.transform(liked_app_ids)
                user_embedding = ncf_model.get_layer('item_embedding')(game_ids_encoded).numpy().mean(axis=0)
            except Exception as e:
                # print(f"Error encoding liked games: {e}")
                user_embedding = None
        else:
            user_embedding = None

    # If user embedding is found, proceed with collaborative filtering
    if user_embedding is not None:
        try:
            # Retrieve item embeddings
            item_embeddings = ncf_model.get_layer('item_embedding').get_weights()[0]
            similarity_scores = cosine_similarity(user_embedding.reshape(1, -1), item_embeddings).flatten()
            top_indices = similarity_scores.argsort()[-top_n:][::-1]  # Get top N recommendations

            top_recommended_app_ids = game_encoder.inverse_transform(top_indices)

            # Filter recommendations based on app_ids
            recommendations = filtered_games[filtered_games['app_id'].isin(top_recommended_app_ids)]
            missing_app_ids = [app_id for app_id in top_recommended_app_ids if app_id not in filtered_games['app_id'].values]

            # If not enough recommendations from collaborative filtering, use fallback
            if recommendations.empty or len(recommendations) < top_n:
                # print(f"Not enough recommendations from collaborative filtering, falling back to advanced metadata search.")
                fallback_recommendations = get_advanced_similar_games(
                    user_query=game_titles,  # Pass the liked games or game titles
                    genres=session.user_preferences.get("genres", []),  # Pass the user's genre preferences
                    release_year_filter=session.user_preferences.get("release_year_filter"),  # Pass the year filter
                    k=top_n  # Limit to top_n recommendations
                )
                recommendations = pd.concat([recommendations, fallback_recommendations], ignore_index=True)

        except Exception as e:
            print(f"Error during collaborative filtering process: {e}")
            # Fallback to advanced metadata search if any error happens
            recommendations = get_advanced_similar_games(
                user_query=game_titles,  # Use game_titles or empty string as fallback
                genres=session.user_preferences.get("genres", []),  # Pass genres from session
                release_year_filter=session.user_preferences.get("release_year_filter"),  # Pass release year filter
                k=top_n  # Limit to top_n recommendations
            )
    else:
        # If no user_embedding could be calculated (no user_id or no liked games), fallback to metadata search
        # print(f"Collaborative filtering failed, falling back to advanced metadata search.")
        recommendations = get_advanced_similar_games(
            user_query=game_titles,  # Use game_titles or empty string as fallback
            genres=session.user_preferences.get("genres", []),  # Pass liked genres or empty
            release_year_filter=session.user_preferences.get("release_year_filter"),  # Pass release year filter if available
            k=top_n  # Limit to top_n recommendations
        )

    # Return the top_n recommendations (no more than top_n, in case of overflow from the fallback)
    return recommendations.head(top_n)


def get_game_info_with_fallback(app_id, combined_df, games_csv, games_metadata):
    """
    Retrieve game information with fallback if not found in combined_df.
    """
    # Check in combined_df
    if app_id in combined_df['app_id'].values:
        game_info = combined_df[combined_df['app_id'] == app_id][['title', 'description']]
        return game_info

    # Fallback to games.csv
    elif app_id in games_csv['app_id'].values:
        game_info = games_csv[games_csv['app_id'] == app_id][['title']]
        game_info['description'] = game_info.get('description', "No description available.")
        return game_info

    # Fallback to games_metadata.json
    else:
        metadata_entry = next((entry for entry in games_metadata if entry['app_id'] == app_id), None)
        if metadata_entry:
            title = metadata_entry.get('title', 'Unknown Title')
            description = metadata_entry.get('description', 'No description available.')
            return pd.DataFrame({'title': [title], 'description': [description]})

    # If not found in any source
    return pd.DataFrame(columns=['title', 'description'])

from fuzzywuzzy import fuzz
import pandas as pd

def get_advanced_similar_games(user_query, genres=None, release_year_filter=None, k=5, similarity_threshold=95):
    """
    Retrieve the top k similar games to the user query, with genre and release year filtering, and fuzzy matching.
    """
    # Combine user_query into a single query text
    query_text = " ".join(user_query) if isinstance(user_query, list) else user_query

    # Step 1: Perform similarity search with a larger retrieval set (increase k)
    results = vector_store.similarity_search(query=query_text, k=k * 5)  # Increase k to get more results


    # Step 3: Filter out irrelevant content (DLC, Mods, etc.) from combined_df
    exclude_keywords = ['DLC', 'Bonus Content', 'Expansion', 'Mod']
    filtered_df = combined_df[~combined_df['title'].str.contains('|'.join(exclude_keywords), case=False, na=False)]

    # Step 4: Filter by app_ids from the similarity search
    app_ids_from_results = [doc.metadata['app_id'] for doc in results]
    recommendations = filtered_df[filtered_df['app_id'].isin(app_ids_from_results)]

    # Step 5: Apply genre filtering if provided
    if genres:
        recommendations = recommendations[recommendations['tags'].apply(
            lambda tags: any(genre.lower() in (tag.lower() for tag in tags) for genre in genres)
        )]

    # Step 6: Apply release year filtering
    if release_year_filter:
        recommendations['date_release'] = pd.to_datetime(recommendations['date_release'], errors='coerce')
        comparator, year = release_year_filter.get("comparator"), release_year_filter.get("year")
        if comparator == "after":
            recommendations = recommendations[recommendations['date_release'].dt.year > year]
        elif comparator == "before":
            recommendations = recommendations[recommendations['date_release'].dt.year < year]
        elif comparator == "exact":
            recommendations = recommendations[recommendations['date_release'].dt.year == year]

    # Step 7: Apply fuzzy matching to remove very similar titles
    unique_recommendations = []
    seen_titles = []

    for _, row in recommendations.iterrows():
        title = row['title']
        # Apply fuzzy matching to filter out very similar titles
        if len(unique_recommendations) < k or all(fuzz.ratio(title, seen_title) < similarity_threshold for seen_title in seen_titles):
            unique_recommendations.append(row)
            seen_titles.append(title)
        if len(unique_recommendations) >= k:
            break

    # Convert unique recommendations to DataFrame and return
    unique_recommendations_df = pd.DataFrame(unique_recommendations)


    return unique_recommendations_df.head(k)

def extract_game_titles(user_message):
    prompt = f"""<s>[INST] Extract the video game titles from this message.
Message: "{user_message}"

Reply with ONLY the game titles, separated by commas. No other text.
Example output format: The Witcher 3, Cyberpunk 2077 [/INST]"""

    inputs = tokenizer(prompt, return_tensors="pt", padding=True, truncation=True, max_length=256)
    inputs = {key: value.to(model.device) for key, value in inputs.items()}

    try:
        response = model.generate(
            **inputs,
            max_new_tokens=50,
            do_sample=False,
            pad_token_id=tokenizer.pad_token_id
        )
        result = tokenizer.decode(response[0], skip_special_tokens=True).strip()

        # Clean up the response
        if '[INST]' in result:
            result = result.split('[/INST]')[-1].strip()

        # Split by comma and clean each title
        titles = [title.strip() for title in result.split(',')]

        # Filter out non-title content
        titles = [t for t in titles if t and not any(x in t.lower() for x in ['message:', 'example:', 'output:', 'format:'])]

        return titles
    except Exception as e:
        # print(f"Error extracting game titles: {e}")
        return []

# Helper function to filter disliked games
def filter_disliked_games(recommendations_df, disliked_games):
    try:
        if not isinstance(recommendations_df, pd.DataFrame):
            return pd.DataFrame(columns=['title', 'description'])

        if not disliked_games:
            return recommendations_df

        # Case-insensitive filtering for disliked games
        mask = ~recommendations_df['title'].str.lower().isin([g.lower() for g in disliked_games])
        return recommendations_df[mask]

    except Exception as e:
        print(f"Error filtering disliked games: {e}")
        return recommendations_df

def filter_redundant_titles(recommendations, similarity_threshold=85):
    """
    Filters out redundant titles that have high similarity scores based on partial title matching.
    """
    unique_recommendations = []
    seen_titles = set()

    for _, row in recommendations.iterrows():
        title = row['title']
        # Check similarity with existing titles in seen_titles set
        if all(fuzz.partial_ratio(title, seen_title) < similarity_threshold for seen_title in seen_titles):
            unique_recommendations.append(row)
            seen_titles.add(title)
        if len(unique_recommendations) >= 5:  # Limit results to top 5 unique recommendations
            break

    # Return DataFrame with unique recommendations
    return pd.DataFrame(unique_recommendations)

def get_app_ids_by_fuzzy_matching(game_titles, games_df, threshold=85):
    """
    Match game titles with app IDs using fuzzy matching on the title column.
    """
    app_ids = []
    for title in game_titles:
        # Normalize the input title
        normalized_input = title.lower().strip()

        # Match against lowercase versions of titles in the DataFrame
        matches = process.extract(normalized_input, games_df['title'].str.lower(), limit=1)

        if matches and matches[0][1] >= threshold:
            matched_title = matches[0][0]
            # Find the original case title and get its app_id
            matched_game = games_df[games_df['title'].str.lower() == matched_title]
            if not matched_game.empty:
                app_ids.append(matched_game.iloc[0]['app_id'])

    return app_ids

import pandas as pd

def metadata_and_llm_fallback(user_message, liked_games, session, k=5):
    # Assuming `liked_games` and other parameters are extracted from the user session
    query_text = " ".join(liked_games) if liked_games else user_message
    results = vector_store.similarity_search(query=query_text, k=k)
    app_ids = [doc.metadata['app_id'] for doc in results]
    recommendations = combined_df[combined_df['app_id'].isin(app_ids)]

    # Retrieve user preferences (genres and release year filter) from session if available
    genres = session.user_preferences.get("genres", [])
    release_year_filter = session.user_preferences.get("release_year_filter")

    # Apply genre filtering if provided
    if genres:
        # Normalize genres and tags for better matching
        genres = [genre.lower() for genre in genres]  # Normalize user preferences
        recommendations['genre_match'] = recommendations['tags'].apply(
            lambda tags: any(genre.lower() in (t.lower() for t in tags) for genre in genres)
        )
        recommendations = recommendations[recommendations['genre_match']]

    # Apply release year filtering
    if release_year_filter:
        recommendations['date_release'] = pd.to_datetime(recommendations['date_release'], errors='coerce')
        comparator, year = release_year_filter.get("comparator"), release_year_filter.get("year")

        # Ensure filtering is done properly based on the 'date_release' column
        if comparator == "after":
            recommendations = recommendations[recommendations['date_release'].dt.year > year]
        elif comparator == "before":
            recommendations = recommendations[recommendations['date_release'].dt.year < year]
        elif comparator == "exact":
            recommendations = recommendations[recommendations['date_release'].dt.year == year]

    # Return the top k recommendations, including title and description
    return recommendations[['title', 'description']].head(k)



def handle_content_filter(update: Update, context: CallbackContext) -> None:
    """Handle the '/filter' command to set content preferences."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    user_preferences = infer_user_preferences_with_llm(user_message)

    excluded_tags = user_preferences.get('excluded_tags', [])

    if not excluded_tags:
        update.message.reply_text("No specific content preferences were found. Let me know if you'd like to adjust your preferences!")
        return

    # Update the session with excluded tags
    session.set_excluded_tags(excluded_tags)

    update.message.reply_text(f"Your content preferences have been updated. Excluded tags: {', '.join(excluded_tags)}. Let me know if you'd like to adjust them further!")


def handle_additional_info(update: Update, context: CallbackContext) -> None:
    """Handle the '/additionalinfo' command to process extra user info like Steam ID."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    # Extract Steam ID from the user's message
    steam_id = extract_steam_id(user_message)
    if steam_id:
        session.set_user_id(steam_id)
        # Fetch and analyze the user's Steam profile
        profile_data = fetch_steam_profile(steam_id)
        if profile_data:
            user_preferences = analyze_profile(profile_data)
            session.update_preferences(user_preferences)

            # Prepare the profile summary message
            total_playtime = user_preferences.get('total_playtime', 0)
            most_played_games = user_preferences.get('most_played_games', [])
            favorite_genres = user_preferences.get('favorite_genres', [])

            # Format the message
            profile_summary = (
                f"Thanks! I've updated your preferences based on your Steam ID `{steam_id}`.\n\n"
                f"📊 *Your Steam Profile Summary:*\n"
                f"🎮 *Total Playtime:* {total_playtime} hours\n"
                f"🔥 *Most Played Games:*\n"
            )

            # Add most played games
            for game in most_played_games:
                profile_summary += f"- {game}\n"

            profile_summary += f"\n🎭 *Favorite Genres:* {', '.join(favorite_genres)}"

            # Send the message with Markdown formatting
            update.message.reply_text(profile_summary, parse_mode='Markdown')
        else:
            update.message.reply_text("I couldn't retrieve your Steam profile data. Please ensure your Steam profile is public and try again.")
    else:
        update.message.reply_text("Please provide a valid Steam ID.")




def handle_out_of_context_response(update: Update, context: CallbackContext) -> None:
    """Handle messages that are out of the gaming context."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    # Optionally provide a brief answer
    prompt = f"""<s>[INST] The user has asked a question that is out of the gaming context:

User Message: "{user_message}"

Redirect the conversation back to gaming topics.

Response:[/INST]"""

    inputs = tokenizer(prompt, return_tensors="pt").to(device)

    response = model.generate(
        **inputs,
        max_new_tokens=100,
        do_sample=True,
        temperature=0.7,
        top_p=0.9,
        pad_token_id=tokenizer.pad_token_id
    )

    result = tokenizer.decode(response[0], skip_special_tokens=True).strip()
    response = generate_custom_response(result)

    update.message.reply_text(response)


def handle_unknown_intent(update: Update, context: CallbackContext) -> None:
    """Default handler for messages that don't match any command."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    response = generate_custom_response("Could you tell me more about what kinds of games you're interested in?")
    update.message.reply_text(response)


def handle_game_comparison(update: Update, context: CallbackContext) -> None:
    """Handle the '/compare' command to compare two games."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    global games_complete_df

    game_titles = extract_game_titles(user_message)
    if len(game_titles) >= 2:
        game1_title = game_titles[0]
        game2_title = game_titles[1]

        game1_info = get_game_info_by_title(game1_title, games_complete_df)
        game2_info = get_game_info_by_title(game2_title, games_complete_df)

        if game1_info.empty or game2_info.empty:
            missing_games = []
            if game1_info.empty:
                missing_games.append(game1_title)
            if game2_info.empty:
                missing_games.append(game2_title)
            response = generate_custom_response(f"Sorry, I couldn't find information on {', '.join(missing_games)}.")
            update.message.reply_text(response)
        else:
            comparison = compare_games(game1_info, game2_info)
            response = generate_custom_response(comparison)
            update.message.reply_text(response)
    else:
        response = generate_custom_response("Please mention two games you'd like me to compare.")
        update.message.reply_text(response)
def handle_recommend_games(update: Update, context: CallbackContext) -> None:
    logging.info("Starting /recommend command handler")

    try:
        # Retrieve user ID and message
        user_id = update.message.chat_id
        user_message = update.message.text
        logging.info(f"User ID: {user_id}")
        logging.info(f"Message: {user_message}")

        # Notify user that the request is being processed
        update.message.reply_text("Processing your request. Please wait...")

        # Show typing indicator
        context.bot.send_chat_action(chat_id=user_id, action=ChatAction.TYPING)

        # Retrieve or create a user session
        session = get_user_session(user_id)
        logging.info(f"User session retrieved: {session.__dict__}")

        # Translate the user message if needed
        try:
            translated_message, detected_language = handle_translation(update, user_message, session)
            logging.info(f"Translated message: {translated_message}, Detected language: {detected_language}")
        except Exception as e:
            logging.error(f"Translation error: {e}")
            update.message.reply_text("An error occurred during translation. Please try again later.")
            return

        if not translated_message:
            update.message.reply_text("Could not process the message. Please try again.")
            return

        # Extract game titles from the translated message
        game_titles = extract_game_titles(translated_message)
        logging.info(f"Extracted game titles: {game_titles}")

        if not game_titles:
            update.message.reply_text("Could you please specify which game you'd like recommendations similar to?")
            return

        # Infer user preferences from the message
        try:
            user_preferences = infer_user_preferences_with_llm(user_message)
            logging.info(f"Inferred user preferences: {user_preferences}")
        except Exception as e:
            logging.error(f"Preference inference error: {e}")
            user_preferences = {"liked_games": game_titles, "excluded_tags": []}

        # Update session with user preferences
        liked_games = user_preferences.get("liked_games", game_titles)
        session.update_likes(liked_games)
        logging.info(f"Updated liked games in session: {session.liked_games}")

        excluded_tags = user_preferences.get("excluded_tags", [])
        session.set_excluded_tags(excluded_tags)
        logging.info(f"Updated excluded tags in session: {session.excluded_tags}")

        # Filter games based on user preferences
        try:
            global games_complete_df
            filtered_games = filter_disliked_games(games_complete_df, session.disliked_games)
            logging.info(f"Games count after filtering dislikes: {len(filtered_games)}")

            # Exclude games with unwanted tags or genres
            exclude_tags = session.get_excluded_tags()
            if exclude_tags:
                for tag in exclude_tags:
                    filtered_games = filtered_games[~filtered_games['tags'].str.contains(tag, case=False, na=False)]
                    filtered_games = filtered_games[~filtered_games['genres'].str.contains(tag, case=False, na=False)]
                    if 'themes' in filtered_games.columns:
                        filtered_games = filtered_games[~filtered_games['themes'].str.contains(tag, case=False, na=False)]
            logging.info(f"Games count after applying content filters: {len(filtered_games)}")
        except Exception as e:
            logging.error(f"Game filtering error: {e}")
            update.message.reply_text("An error occurred while filtering the games. Please try again.")
            return

        # Generate recommendations using collaborative filtering
        try:
            recommendations = collaborative_filtering_with_fallback(
                session.user_id or None, filtered_games, session, game_titles=liked_games
            )

            if recommendations.empty:
                update.message.reply_text("Sorry, I couldn't find any suitable recommendations based on your preferences.")
                return

            # Generate and send recommendations to the user
            response = generate_response(user_message, recommendations, session)
            logging.info(f"Generated response: {response}")
            update.message.reply_text(response, parse_mode='Markdown')

        except Exception as e:
            logging.error(f"Recommendation generation error: {e}")
            update.message.reply_text("An error occurred while generating recommendations. Please try again.")
    except Exception as general_error:
        logging.error(f"Unexpected error in handle_recommend_games: {general_error}")
        update.message.reply_text("An unexpected error occurred. Please try again later.")


def handle_feedback_response(update: Update, context: CallbackContext) -> None:
    """Handle the '/feedback' command to process user feedback."""
    user_message = update.message.text
    user_id = update.message.chat_id
    session = get_user_session(user_id)

    # Acknowledge feedback and ask for more details
    prompt = f"""<s>[INST] The user has provided feedback on the recommendations:

User Message: "{user_message}"

Provide a really short polite acknowledgment and ask for more details to improve future recommendations.

Response:[/INST]"""

    inputs = tokenizer(prompt, return_tensors="pt").to(device)

    response = model.generate(
        **inputs,
        max_new_tokens=100,
        do_sample=True,
        temperature=0.7,
        top_p=0.9,
        pad_token_id=tokenizer.pad_token_id
    )

    result = tokenizer.decode(response[0], skip_special_tokens=True).strip()

    # Generate custom response to be sent back to the user
    response = generate_custom_response(result)
    update.message.reply_text(response)

# def parse_user_intent(user_message):
#     """
#     Infers the intent behind user messages and classifies accordingly.
#     """
#     prompt = f"""<s>[INST] You are an assistant that classifies user messages into exactly one category based on the content.

# Message: "{user_message}"

# Categories:
# 1. recommend_games - User wants game suggestions.
# 2. feedback - User expresses likes/dislikes about a game or service.
# 3. additional_info - User provides Steam ID, account info, or similar details.
# 4. out_of_context - The message is unrelated to games, feedback, or account information.
# 5. game_comparison - User wants a comparison between games.
# 6. opinion_request - User asks for an opinion on a specific game.
# 7. top_games_request - User asks for top-rated games OR genres in a category.
# 8. video_search - User requests a gameplay video or trailer.
# 9. user_gaming_profile - User wants to create a gaming profile based on their Steam account.
# 10. translation - User wants to translate text.
# 11. price_tracker - User wants to track game prices.
# 12. gaming_news - User asks for gaming news.
# 13. genre_exploration - User wants suggestions for new genres.
# 14. content_filter - User wants to exclude certain content.
# 15. game_session_reminder - User wants to set a reminder

# Output the category name only (e.g., recommend_games, feedback, video_search, etc.). Do not include any additional text.[/INST]"""

#     valid_intents = [
#         "recommend_games", "feedback", "additional_info", "out_of_context",
#         "game_comparison", "opinion_request", "top_games_request", "video_search",
#         "user_gaming_profile", "translation", "price_tracker", "gaming_news",
#         "genre_exploration", "content_filter", "game_session_reminder"
#     ]

#     inputs = tokenizer(prompt, return_tensors="pt").to(device)

#     response = model.generate(
#         **inputs,
#         max_new_tokens=10,
#         do_sample=True,
#         temperature=0.7,
#         top_p=0.9,
#         pad_token_id=tokenizer.pad_token_id
#     )

#     result = tokenizer.decode(response[0], skip_special_tokens=True).strip().lower()
#     result = result.split()[-1]

#     # Extract the intent from the result
#     for intent in valid_intents:
#         if intent in result:
#             return intent
#     return "unknown"

def parse_user_intent(user_message):
    """
    Classify the user's message into a predefined intent category.
    """
    prompt = f"""[INST] Classify this message into one category. Reply with ONLY the category name.
Message: "{user_message}"

Categories:
recommend_games: asking for game suggestions
feedback: sharing opinions about games
additional_info: sharing account info
out_of_context: not about games
game_comparison: comparing games
opinion_request: asking about specific games
top_games_request: asking for top-rated best games among genres
video_search: wanting game videos (walktroughs, trailers, etc) on games provided
user_gaming_profile: profile creation
translation: needs translation
price_tracker: asking about prices
gaming_news: asking about updates
genre_exploration: exploring genres
content_filter: filtering content
game_session_reminder: gaming schedules (setting or checking reminders)

Examples:
"Can you recommend games like Dark Souls?" → recommend_games
"I hate this game" → feedback
"What's your favorite recipe?" → out_of_context
"What do you think about the new Silent Hill?" → opinion_request  # Clear distinction here
"Do you have any info on the new Elder Scrolls?" → gaming_news  # Ensure this is categorized correctly
"How does Assassin's Creed compare to Far Cry?" → game_comparison  # Comparison example
"Can you remind me to play at 9:00 PM every evening?" → game_session_reminder  # Reminder setting example
"What's my next reminder?" → game_session_reminder  # Checking reminder example
[/INST]"""

    try:
        inputs = tokenizer(
            prompt,
            return_tensors="pt",
            padding=True,
            truncation=True,
            max_length=512
        )

        inputs = {key: value.to(model.device) for key, value in inputs.items()}

        response = model.generate(
            **inputs,
            max_new_tokens=20,
            do_sample=False,  # Set to False for more deterministic outputs
            num_beams=1,
            pad_token_id=tokenizer.pad_token_id,
            eos_token_id=tokenizer.eos_token_id
        )

        # Decode and clean up the response
        result = tokenizer.decode(response[0], skip_special_tokens=True).strip().lower()

        # Clean up the result by removing the instruction prompt
        if '[inst]' in result:
            result = result.split('[/inst]')[-1].strip()

        # Further clean up to get just the category
        valid_intents = [
            "recommend_games", "feedback", "additional_info", "out_of_context",
            "game_comparison", "opinion_request", "top_games_request", "video_search",
            "user_gaming_profile", "translation", "price_tracker", "gaming_news",
            "genre_exploration", "content_filter", "game_session_reminder"
        ]

        # Look for exact matches first
        for intent in valid_intents:
            if intent in result:
                return intent

        # Rule-based handling for feedback vs. opinion_request
        if any(phrase in user_message.lower() for phrase in ["what do you think about", "how do you feel about", "opinion on"]):
            return "opinion_request"

        # Rule-based handling for gaming_news vs. game_comparison
        if "info on" in user_message.lower() or "news about" in user_message.lower():
            return "gaming_news"
        elif "compare" in user_message.lower() or "vs" in user_message.lower():
            return "game_comparison"

        # If no exact match, try to find the closest match
        words = result.split()
        for word in words:
            for intent in valid_intents:
                if intent in word:
                    return intent

        print(f"No valid intent found in response: {result}")
        return "unknown"

    except Exception as e:
        print(f"Error processing message: {e}")
        return "unknown"

def recommend_games(user_message, session):
    # Detect language
    user_language = detect_language(user_message)

    # Translate to English if necessary
    if user_language != 'en':
        original_message = user_message
        user_message = translate_to_english(user_message)
    else:
        original_message = None

    # Normalize message
    normalized_message = user_message.lower().strip()

    # Handle greetings and farewells
    if normalized_message in ['hello', 'hi', 'hey', 'hello!', 'hi!', 'hey!']:
        response = "Hi there! I'd love to help you discover some great games. What kinds of games do you enjoy?"
    elif normalized_message in ['goodbye', 'bye', 'see you', 'goodbye!', 'bye!']:
        response = "Take care! Come back anytime for more game recommendations!"
    else:
        # Parse intent
        intent = parse_user_intent(user_message)

        # Intent handlers
        intent_handlers = {
            "recommend_games": handle_recommend_games,
            "feedback": handle_feedback_response,
            "additional_info": handle_additional_info,
            "out_of_context": handle_out_of_context_response,
            "game_comparison": handle_game_comparison,
            "opinion_request": handle_opinion_request,
            "top_games_request": handle_top_games_request,
            "video_search": handle_video_search,
            "user_gaming_profile": handle_user_gaming_profile,
            "translation": handle_translation,
            "price_tracker": handle_price_tracker,
            # "gaming_news": handle_gaming_news,
            "game_session_reminder": handle_game_session_reminder,
            "content_filter": handle_content_filter
        }

        handler = intent_handlers.get(intent, handle_unknown_intent)
        response = handler(user_message, session)

    # Translate response back to user's language if necessary
    if original_message:
        response = translate_from_english(response, user_language)

    return response



def generate_custom_response(prompt, max_new_tokens=150):
    """
    Generate a response using the LLM and ensure that prompt instructions are removed.
    """
    inputs = tokenizer(prompt, return_tensors="pt", padding=True, truncation=True, max_length=512)
    inputs = {key: value.to(model.device) for key, value in inputs.items()}

    try:
        response = model.generate(
            **inputs,
            max_new_tokens=max_new_tokens,
            do_sample=True,
            temperature=0.5,
            top_p=0.9,
            repetition_penalty=1.15,
            pad_token_id=tokenizer.pad_token_id
        )
        generated_text = tokenizer.decode(response[0], skip_special_tokens=True).strip()

        # Improved cleaning pattern to remove unwanted content
        patterns = [
            r'\[INST\].*?\[/INST\]',  # Remove INST tags and content
            r'<s>|</s>',  # Remove start/end tokens
            r'You are having.*?Reply to:.*?(?=\w)',  # Remove instruction text
            r'^\s*[-•]\s*',  # Remove any bullet points
            r'\n\s*\n',  # Remove multiple newlines
        ]

        cleaned_response = generated_text
        for pattern in patterns:
            cleaned_response = re.sub(pattern, '', cleaned_response, flags=re.DOTALL | re.IGNORECASE).strip()

        # Final cleanup of extra spaces
        cleaned_response = re.sub(r'\s+', ' ', cleaned_response).strip()

        # Ensure response is not unexpectedly short
        if len(cleaned_response.split()) < 5:
            return "I'm here to help with game recommendations! Let me know what you're looking for."

        return cleaned_response
    except Exception as e:
        print(f"Error during response generation: {e}")
        return "I'm here to assist with game recommendations! Let me know how I can help."

def generate_response(user_message, recommendations, session):
    """
    Generate a dynamic response with recommendations, letting the model create conversational output.
    """

    # Generate a list of recommended games with titles and truncated descriptions
    recommendation_list = "\n\n".join([
        f"{i}. *{row['title']}*\n{row['description'][:200]}..."
        for i, (idx, row) in enumerate(recommendations.head(3).iterrows(), 1)
    ])

    # Prepare a detailed prompt for the model to generate a friendly and engaging response
    prompt = f"""[INST]
    You are a helpful game recommendation assistant. Respond naturally based on the user's interests.

    User message: {user_message}

    Recommended games:
    {recommendation_list}

    Provide a friendly, informative response introducing these games in 2-3 sentences. Focus on their common themes or gameplay elements. [/INST]
    """

    # Tokenize the prompt and prepare it for input to the model
    inputs = tokenizer(prompt, return_tensors="pt", padding=True, truncation=True, max_length=512)
    inputs = {key: value.to(model.device) for key, value in inputs.items()}

    try:
        # Generate the response using the model
        response = model.generate(
            **inputs,
            max_new_tokens=200,  # Limit the response length for readability
            do_sample=True,
            temperature=0.65,  # Adjust randomness for a balanced response
            top_p=0.9,
            repetition_penalty=1.15,
            pad_token_id=tokenizer.pad_token_id
        )

        # Decode and clean the generated response
        generated_text = tokenizer.decode(response[0], skip_special_tokens=True).strip()

        # Improved cleaning pattern
        patterns = [
            r'\[INST\].*?\[/INST\]',  # Remove INST tags and content
            r'<s>|</s>',  # Remove start/end tokens
            r'You are having.*?Reply to:.*?(?=\w)',  # Remove instruction text
            r'^\s*[-•]\s*',  # Remove any bullet points
            r'\n\s*\n',  # Remove multiple newlines
        ]

        cleaned_response = generated_text
        for pattern in patterns:
            cleaned_response = re.sub(pattern, '', cleaned_response, flags=re.DOTALL | re.IGNORECASE).strip()

        # Final cleanup of extra spaces
        cleaned_response = re.sub(r'\s+', ' ', cleaned_response).strip()

        # If the model does not generate text, provide a fallback response
        return cleaned_response if cleaned_response else "I'm here to help with game recommendations! Let me know what you're looking for."

    except Exception as e:
        # Catch errors and provide a clear fallback response
        print(f"Error during response generation: {e}")
        return "I apologize, but I couldn't generate recommendations at the moment. Please try again later."



"""### TELEGRAM BOT"""

# !pip install httpx==0.28.0

# !pip show python-telegram-bot

# from telegram import Update
# from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext

def error(update: Update, context: CallbackContext):
    logger.warning(f'Update "{update}" caused error "{context.error}"')

# Set up logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Start command handler
def start(update: Update, context: CallbackContext) -> None:
    update.message.reply_text("Welcome to SteamRecs! I can recommend games based on your preferences and more. See /help for other functions. How can I assist you today?")

# Help command handler
def help_command(update: Update, context: CallbackContext) -> None:
    help_text = """
*Welcome to the SteamRecs Bot! Here are the available commands:*

/start - Start interacting with the bot.
/help - Show this help message.

/recommend - Get game recommendations based on your preferences.
/price <game name> - Track the price for a specific game and receive updates.
/feedback <feedback> - Share your feedback about the recommendations or the bot.
/compare <game1> <game2> - Compare two games and get a detailed analysis.
/opinion <game name> - Get a personal opinion about a game.
/filter <tags> - Filter games by specific tags (e.g., 'mature', 'action', etc.).
/topgames - See a list of top-rated games.
/reminder - Set a reminder for your game session.
/video <game name> - Search for gameplay videos or trailers for a specific game.
"""
    update.message.reply_text(help_text, parse_mode='Markdown')

import logging
import sys

# Set up logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    force=True  # Forces logging reconfiguration
)

# # Test logging
# print("Testing logs...")
# logging.info("This is an INFO log.")
# logging.warning("This is a WARNING log.")
# logging.error("This is an ERROR log.")
# sys.stdout.flush()

# Main function to set up the bot
def main():
    # Telegram bot token (replace with your actual token)
    TELEGRAM_API_TOKEN = '7058766306:AAHBqpnRD3uQIqg5yBev9DTbZY_kawjwkrM'

     # Set up the updater and dispatcher
    updater = Updater(TELEGRAM_API_TOKEN, use_context=True)
    dispatcher = updater.dispatcher

    # Add command handlers to the dispatcher
    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CommandHandler("help", help_command))
    dispatcher.add_handler(CommandHandler("recommend", handle_recommend_games))
    dispatcher.add_handler(CommandHandler("price", handle_price_tracker))
    dispatcher.add_handler(CommandHandler("feedback", handle_feedback_response))
    dispatcher.add_handler(CommandHandler("compare", handle_game_comparison))
    dispatcher.add_handler(CommandHandler("opinion", handle_opinion_request))
    dispatcher.add_handler(CommandHandler("topgames", handle_top_games_request))
    dispatcher.add_handler(CommandHandler("reminder", handle_game_session_reminder))
    dispatcher.add_handler(CommandHandler("filter", handle_content_filter))
    dispatcher.add_handler(CommandHandler("additionalinfo", handle_additional_info))
    dispatcher.add_handler(CommandHandler("video", handle_video_search))

    # Default handler for unknown intents (should be added last)
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_unknown_intent))

    # Set up error handling
    dispatcher.add_error_handler(error)

    # Start the bot
    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()





"""### USE CASES TO RUN"""

test_cases = [
    (1, "Hi!", "Provides greeting (hello/goodbye) and additional info based on prior user interactions", "Mistral LLM", "Yes"),
    (2, "My steam ID is 76561198129676583", "Stores user’s Steam ID and analyzes preferences for recommendations", "Steam-based Model (Neural Collaborative)", "Yes"),
    (2, "My steam ID is 123456", "Stores user’s Steam ID and analyzes preferences for recommendations", "Steam-based Model (Neural Collaborative)", "Yes"),
    (3, "Can you recommend me games like Outlast?", "Delivers game suggestions based on user’s stated preferences (platform, genre, etc.)", "Vector store MiniLM similarity search", "Yes"),
    (4, "What do you think about Signalis?", "Provides brief game descriptions with key features, pros, and cons", "all-MiniLM-L6-v2 + Mistral LLM", "Yes"),
    (5, "How to bake a cake?", "Politely redirects user to game-related queries while offering brief answers for other topics", "Mistral LLM", "Yes"),
    (6, "Recommend top 10 action games", "Lists top-rated games in specified categories based on reviews, awards, and purchase counts", "Steam-based Model + Content-Based Filtering", "Yes"),
    (7, "I want to see the full walkthrough of Alan Wake 2", "Provides a relevant YouTube video link based on user input, filtered by likes and views", "Mistral LLM + YouTube API", "No"),
    (8, "I have a prime time for Overwatch at 9:00 pm every evening, set a reminder", "Sets up a reminder for game sessions on specified dates/times based on user’s input", "Mistral LLM + Custom Functions", "Yes"),
    (9, "Create my gaming profile based on my steam account", "Creates a profile based on Steam ID (favorite genres, most played games, etc.)", "Steam-based Model + Mistral LLM + Steam API", "No"),
    (10, "Порекомендуй игры, похожие на Undertale", "Translates user input and responses", "Mistral LLM + Google Translate API", "No"),
    (11, "Exclude games with mature content", "Excludes games with specified tags based on user input", "Steam-based Model + Content-Based Filtering", "Yes"),
    (12, "I didn’t like your recommendations", "Requests and records user feedback on recommendations for future refinement", "Mistral LLM", "Yes"),
    (14, "Compare Apex Legends to Overwatch", "Compares games based on user criteria (genre, reviews, gameplay, etc.)", "Mistral LLM + Steam Data + all-MiniLM-L6-v2", "Yes"),
    (15, "I love Subnautica, The Last of Us, Horizon Zero Dawn, recommend games",
     "Recommends games similar to the ones mentioned based on user preferences",
     "NCF MODEL", "Yes")
]


# Run the test cases with session reset
def run_test_cases_with_reset(test_cases):
    for test_case in test_cases:
        try:
            # Unpack the test case values properly
            test_case_id, user_message, expected_outcome, model, passes = test_case
        except ValueError as e:
            print(f"Error unpacking test case: {test_case}")
            continue

        # Reset the user session before each test case to prevent carryover
        session = UserSession()

        print(f"Test Case {test_case_id}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")

        print("-" * 50)

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)


# price tracking added
user_message = "Track prices for God of War"
# Call the handler with the user message and the games_complete_df
response = handle_price_tracker(user_message, games_complete_df)
print(response)



"""### USE CASES EXAMPLE"""

# Initialize a new user session
session = UserSession()

test_cases = [
    (1, "Hi!", "Provides greeting (hello/goodbye) and additional info based on prior user interactions", "Mistral LLM", "Yes"),
    (2, "My steam ID is 76561198129676583", "Stores user’s Steam ID and analyzes preferences for recommendations", "Steam-based Model (Neural Collaborative)", "Yes"),
    (2, "My steam ID is 123456", "Stores user’s Steam ID and analyzes preferences for recommendations", "Steam-based Model (Neural Collaborative)", "Yes"),
    (3, "Can you recommend me games like Outlast?", "Delivers game suggestions based on user’s stated preferences (platform, genre, etc.)", "Vector store MiniLM similarity search", "Yes"),
    (4, "What do you think about Signalis?", "Provides brief game descriptions with key features, pros, and cons", "all-MiniLM-L6-v2 + Mistral LLM", "Yes"),
    (5, "How to bake a cake?", "Politely redirects user to game-related queries while offering brief answers for other topics", "Mistral LLM", "Yes"),
    (6, "Recommend top 10 action games", "Lists top-rated games in specified categories based on reviews, awards, and purchase counts", "Steam-based Model + Content-Based Filtering", "Yes"),
    (7, "I want to see the full walkthrough of Alan Wake 2", "Provides a relevant YouTube video link based on user input, filtered by likes and views", "Mistral LLM + YouTube API", "No"),
    (8, "I have a prime time for Overwatch at 9:00 pm every evening, set a reminder", "Sets up a reminder for game sessions on specified dates/times based on user’s input", "Mistral LLM + Custom Functions", "Yes"),
    (9, "Create my gaming profile based on my steam account", "Creates a profile based on Steam ID (favorite genres, most played games, etc.)", "Steam-based Model + Mistral LLM + Steam API", "No"),
    (10, "Порекомендуй игры, похожие на Undertale", "Translates user input and responses", "Mistral LLM + Google Translate API", "No"),
    (11, "Exclude games with mature content", "Excludes games with specified tags based on user input", "Steam-based Model + Content-Based Filtering", "Yes"),
    (12, "I didn’t like your recommendations", "Requests and records user feedback on recommendations for future refinement", "Mistral LLM", "Yes"),
    (14, "Compare Apex Legends to Overwatch", "Compares games based on user criteria (genre, reviews, gameplay, etc.)", "Mistral LLM + Steam Data + all-MiniLM-L6-v2", "Yes"),
    (15, "I love Subnautica, The Last of Us, Horizon Zero Dawn, recommend games",
     "Recommends games similar to the ones mentioned based on user preferences",
     "NCF MODEL", "Yes")
]


# Run the test cases with session reset
def run_test_cases_with_reset(test_cases):
    for test_case in test_cases:
        try:
            # Unpack the test case values properly
            test_case_id, user_message, expected_outcome, model, passes = test_case
        except ValueError as e:
            print(f"Error unpacking test case: {test_case}")
            continue

        # Reset the user session before each test case to prevent carryover
        session = UserSession()

        print(f"Test Case {test_case_id}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")

        print("-" * 50)

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)


# price tracking added
user_message = "Track prices for God of War"
# Call the handler with the user message and the games_complete_df
response = handle_price_tracker(user_message, games_complete_df)
print(response)







"""### PREVIOUS TESTS"""





user_message = "What do you think about Signalis?"
print(extract_game_titles(user_message))

user_message = "Track prices for God of War"
# Call the handler with the user message and the games_complete_df
response = handle_price_tracker(user_message, games_complete_df)
print(response)

# Get the Steam API key from the environment variable
api_key = os.getenv('STEAM_API_KEY')





get_game_info_by_title("Apex Legends", games_complete_df)

games_complete_df[games_complete_df['title'].str.contains("Apex Legends", case=False, na=False)]





# Test code for intent classification
def test_intent_classification(user_message):
    """
    Test the intent classification based on the user message input.
    """
    prompt = f"""[INST] Classify this message into one category. Reply with ONLY the category name.
Message: "{user_message}"

Categories:
recommend_games: asking for game suggestions
feedback: sharing opinions about games
additional_info: sharing account info
out_of_context: not about games
game_comparison: comparing games
opinion_request: asking about specific games
top_games_request: asking for top-rated best games among genres
video_search: wanting game videos (walktroughs, trailers, etc) on games provided
user_gaming_profile: profile creation
translation: needs translation
price_tracker: asking about prices
gaming_news: asking about updates
genre_exploration: exploring genres
content_filter: filtering content
game_session_reminder: gaming schedules (setting or checking reminders)

Examples:
"Can you recommend games like Dark Souls?" → recommend_games
"I hate this game" → feedback
"What's your favorite recipe?" → out_of_context
"What do you think about the new Silent Hill?" → opinion_request  # Clear distinction here
"Do you have any info on the new Elder Scrolls?" → gaming_news  # Ensure this is categorized correctly
"How does Assassin's Creed compare to Far Cry?" → game_comparison  # Comparison example
"Can you remind me to play at 9:00 PM every evening?" → game_session_reminder  # Reminder setting example
"What's my next reminder?" → game_session_reminder  # Checking reminder example
[/INST]"""

    try:
        # Tokenize input for model processing
        inputs = tokenizer(
            prompt,
            return_tensors="pt",
            padding=True,
            truncation=True,
            max_length=512
        )

        inputs = {key: value.to(model.device) for key, value in inputs.items()}

        # Generate model's response
        response = model.generate(
            **inputs,
            max_new_tokens=20,
            do_sample=False,  # Set to False for more deterministic outputs
            num_beams=1,
            pad_token_id=tokenizer.pad_token_id,
            eos_token_id=tokenizer.eos_token_id
        )

        # Decode and clean up the response
        result = tokenizer.decode(response[0], skip_special_tokens=True).strip().lower()

        print(f"Model raw response: {result}")  # Print the raw output

        # Clean up the result by removing the instruction prompt
        if '[inst]' in result:
            result = result.split('[/inst]')[-1].strip()

        # Further clean up to get just the category
        valid_intents = [
            "recommend_games", "feedback", "additional_info", "out_of_context",
            "game_comparison", "opinion_request", "top_games_request", "video_search",
            "user_gaming_profile", "translation", "price_tracker", "gaming_news",
            "genre_exploration", "content_filter", "game_session_reminder"
        ]

        # Look for exact matches first
        for intent in valid_intents:
            if intent in result:
                print(f"Detected intent: {intent}")  # Print detected intent
                return intent

        print(f"No valid intent found in response: {result}")  # Print when no valid intent is found
        return "unknown"

    except Exception as e:
        print(f"Error processing message: {e}")
        return "unknown"


# Test User Message
user_message = "I have a prime time at 9:00 pm every evening, set a reminder"

# Call the testing function
detected_intent = test_intent_classification(user_message)

# Print the detected intent
print(f"Detected Intent: {detected_intent}")

user_message = "Recommend top 10 action games"
response = handle_top_games_request(user_message, session)
print(response)

user_message = "recommander des jeux similaires à Tetris"
intent = parse_user_intent(user_message)
print(f"Detected Intent: {intent}")

print(response)



# Initialize a new user session
session = UserSession()

# Assuming the `infer_user_preferences_with_llm` function is defined somewhere above.

# Test 1: Normal message with liked games, disliked games, genres
user_message_1 = "Порекомендуй игры, похожие на Undertale"
print("Test 1 - User message:", user_message_1)
preferences_1 = infer_user_preferences_with_llm(user_message_1)
print("Preferences:", preferences_1)

# Test 2: Message with only liked games
user_message_2 = "I enjoy playing Skyrim and Witcher 3."
print("\nTest 2 - User message:", user_message_2)
preferences_2 = infer_user_preferences_with_llm(user_message_2)
print("Preferences:", preferences_2)

# Test 3: Empty message (no preferences)
user_message_3 = "I'm just looking for some game recommendations."
print("\nTest 3 - User message:", user_message_3)
preferences_3 = infer_user_preferences_with_llm(user_message_3)
print("Preferences:", preferences_3)

# Test 4: Message with only excluded tags (e.g., horror)
user_message_4 = "I don't like horror games."
print("\nTest 4 - User message:", user_message_4)
preferences_4 = infer_user_preferences_with_llm(user_message_4)
print("Preferences:", preferences_4)

# Test 5: Message with unknown preferences or malformed format
user_message_5 = "Can you suggest some action games?"
print("\nTest 5 - User message:", user_message_5)
preferences_5 = infer_user_preferences_with_llm(user_message_5)
print("Preferences:", preferences_5)





def run_tests():
    """
    Runs tests to verify the updated recommendation functions.
    """
    session = UserSession()

    # Test 1: Parse user intent
    print("Testing parse_user_intent:")
    test_messages = [
        "Can you recommend games like The Witcher 3?",
        "My Steam ID is 12345678",
        "I didn’t like Outlast, please don’t suggest similar games.",
        "What do you think about the new Silent Hill?",
        "Please tell me the best RPG games to play.",
        "I need some videos of Resident Evil 4",
        "How to compare Assassin's Creed and Far Cry?",
        "My gaming profile is public now.",
        "I’m looking for the latest news on Cyberpunk 2077",
        "I want to know prices for Call of Duty.",
        "Do you have any info on the new Elder Scrolls?",
        "I need some help with translation.",
        "What genres are popular right now?"
    ]

    for msg in test_messages:
        intent = parse_user_intent(msg)  # Using your original parse_user_intent function
        print(f"Message: {msg}\nIntent: {intent}\n")

# Run tests
run_tests()







# Function to run test cases and reset session for each case
def run_test_cases_with_reset(test_cases):
    for i, user_message in enumerate(test_cases):
        # Reset the user session before each test case to prevent carryover
        session = UserSession()

        print(f"Test Case {i+1}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")
        print("-" * 50)

# Define unique test cases, including off-topic and game-specific queries
test_cases = [
    "Can you recommend some games similar to Skyrim?",  # Game recommendation request
    "I'm into horror games, could you recommend something similar to Outlast?",  # Genre-specific recommendation
    "Do you have any recommendations for multiplayer FPS games?",  # Multiplayer FPS focus
    "My Steam ID is 12345678.",  # Providing Steam ID
    "I didn’t enjoy playing Cyberpunk 2077.",  # Feedback on a disliked game
    "I love fantasy games with magic. Any suggestions?",  # Fantasy genre request
    "What's a good RPG with a compelling story?",  # RPG story-driven recommendation
    "Do you know of any educational games for children?",  # Educational game request
    "Could you recommend some games with relaxing gameplay?",  # Calm/relaxing games
    "Any good co-op games to play with friends?",  # Co-op multiplayer game request
    "I'm looking for games with deep lore. Got any suggestions?",  # Games with rich lore
    "Can you recommend a movie similar to Lord of the Rings?",  # Off-topic movie request
    "I need a recipe for a quick pasta dish.",  # Non-game cooking query
    "Tell me a fun fact about space!",  # Random educational query
    "What’s the best way to learn Python programming?",  # Off-topic programming question
]

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)











def run_tests():
    # Initialize user session for testing
    session = UserSession()

    # Test 1: Parse user intent
    print("Testing parse_user_intent:")
    test_messages = [
        "Can you recommend games like The Witcher 3?",
        "My Steam ID is 12345678",
        "I didn’t like Outlast, please don’t suggest similar games."
    ]
    for msg in test_messages:
        intent = parse_user_intent(msg)
        print(f"Message: {msg}\nIntent: {intent}\n")

    # Test 2: Extract game titles
    print("\nTesting extract_game_titles:")
    test_titles = [
        "I love The Witcher 3 and Cyberpunk 2077",
        "I didn’t enjoy playing Outlast",
        "Can you recommend games like Skyrim?"
    ]
    for msg in test_titles:
        titles = extract_game_titles(msg)
        print(f"Message: {msg}\nExtracted titles: {titles}\n")

    # Test 3: Extract Steam ID
    print("\nTesting extract_steam_id:")
    test_ids = [
        "Here is my Steam ID: 12345678",
        "Can you find games for Steam ID 87654321?",
        "No ID here!"
    ]
    for msg in test_ids:
        steam_id = extract_steam_id(msg)
        print(f"Message: {msg}\nSteam ID: {steam_id}\n")

    # Test 8: Content-based filtering on recommendations
    print("\nTesting content_based_filtering:")
    user_preferences = {
        'include_genres': ['RPG'],
        'exclude_genres': ['Horror'],
        'developer_type': 'AAA',
        'start_year': 2015,
        'end_year': 2021
    }
    content_filtered = content_based_filtering(user_preferences, combined_df)
    print("Content-based filtered recommendations (first 3):")
    print(content_filtered[['title', 'description']].head(3) if not content_filtered.empty else "No recommendations found.")

    # Test 9: Generate response with recommendations
    print("\nTesting generate_response:")
    response = generate_response("Can you suggest some RPG games?", recommendations, session)
    print("Generated response:")
    print(response)

# Run the tests
run_tests()

def run_tests():
    """
    Runs tests to verify the updated recommendation functions.
    """
    session = UserSession()
    # Test 1: Parse user intent
    print("Testing parse_user_intent:")
    test_messages = [
        "Can you recommend games like The Witcher 3?",
        "My Steam ID is 12345678",
        "I didn’t like Outlast, please don’t suggest similar games."
    ]
    for msg in test_messages:
        intent = parse_user_intent(msg)
        print(f"Message: {msg}\nIntent: {intent}\n")

    # Test 2: Collaborative filtering with user_id
    print("\nTesting collaborative_filtering_with_fallback with user_id:")
    session.set_user_id(12345678)  # Sample user ID
    response = collaborative_filtering_with_fallback(session.user_id, combined_df, session)
    print("Collaborative filtering response with user_id:")
    print(response)

    # Test 3: Metadata and LLM fallback
    print("\nTesting metadata_and_llm_fallback:")
    response = metadata_and_llm_fallback(["The Witcher 3", "Cyberpunk 2077"], genres=["RPG", "Open World"])
    print("Metadata and LLM fallback response:")
    print(response)

# Run tests
run_tests()

user_id = 11140739
if user_id in user_encoder.classes_:
    print("User ID is recognized.")
else:
    print("User ID is not recognized.")

user_id_1 = 12345678
user_id_2 = 11140739

# Encode the user IDs
user_id_1_encoded = user_encoder.transform([user_id_1])
user_id_2_encoded = user_encoder.transform([user_id_2])

# Retrieve user embeddings from the NCF model
user_embedding_1 = ncf_model.get_layer('user_embedding')(user_id_1_encoded).numpy()
user_embedding_2 = ncf_model.get_layer('user_embedding')(user_id_2_encoded).numpy()

# Check if embeddings are identical
are_embeddings_identical = (user_embedding_1 == user_embedding_2).all()
print("Are embeddings identical for both users?", are_embeddings_identical)

# Function to generate and print recommendations for a given user_id
def get_and_print_recommendations(user_id):
    # Encode the user ID and retrieve the user embedding
    user_id_encoded = user_encoder.transform([user_id])
    user_embedding = ncf_model.get_layer('user_embedding')(user_id_encoded).numpy()

    # Generate recommendations for this user's embedding
    # Assuming you use a similarity-based approach for recommendations
    item_embeddings = ncf_model.get_layer('item_embedding').get_weights()[0]
    similarity_scores = cosine_similarity(user_embedding, item_embeddings).flatten()

    # Sort items by similarity score and get top recommendations
    top_indices = similarity_scores.argsort()[-10:][::-1]  # Adjust top N as needed
    top_recommended_app_ids = game_encoder.inverse_transform(top_indices)

    # Retrieve and display the recommended games from the original DataFrame
    recommended_games = combined_df[combined_df['app_id'].isin(top_recommended_app_ids)]
    print(f"Recommendations for User ID {user_id}:")
    print(recommended_games[['title', 'description']])

get_and_print_recommendations(user_id_1)
get_and_print_recommendations(user_id_2)





# Sample game titles for debugging
test_titles = ["The Witcher 3", "Cyberpunk 2077", "Outlast"]

# Ensure the titles in games_df are normalized
def normalize_title(title):
    title = title.lower()
    title = re.sub(r'[^\w\s]', '', title)  # Remove punctuation
    title = re.sub(r'\s+', ' ', title).strip()  # Remove extra whitespace
    return title

# Apply normalization to games_df for matching consistency
games_df['normalized_title'] = games_df['title'].apply(normalize_title)

# Run get_app_ids_by_fuzzy_matching and print results
app_ids = get_app_ids_by_fuzzy_matching(test_titles, games_df)
print("Matched app IDs:", app_ids)

# Inspect if matched titles are what we expect
for app_id in app_ids:
    matched_title = games_df[games_df['app_id'] == app_id]['title'].iloc[0]
    print(f"Matched title for app_id {app_id}: {matched_title}")

# Sample liked games and genres for fallback testing
liked_games = ["The Witcher 3", "Cyberpunk 2077"]
genres = ["RPG", "Open World"]

# Run similarity search as a fallback
def debug_similarity_search(user_query, genres):
    recommendations = get_advanced_similar_games(user_query=user_query, genres=genres)
    print("Similarity search fallback recommendations:")
    if not recommendations.empty:
        print(recommendations[['title', 'description']].head(5))
    else:
        print("No recommendations found in similarity search.")

# Test similarity search fallback
debug_similarity_search(liked_games, genres)



# Check the first few rows of combined_df
print("First few rows of combined_df:")
print(combined_df.head())

# Check the data type of the 'app_id' column
print("\nData type of app_id column in combined_df:")
print(combined_df['app_id'].dtype)

# Check for any missing values in app_id
missing_app_ids = combined_df['app_id'].isnull().sum()
print(f"\nNumber of missing values in app_id column: {missing_app_ids}")

# Display the unique app_ids present in combined_df
unique_app_ids = combined_df['app_id'].unique()
print(f"\nNumber of unique app_ids in combined_df: {len(unique_app_ids)}")

# Sample some specific app_ids you may want to check for
sample_app_ids = [1571600 , 1479470 ]  # Replace with any IDs you are checking
print(f"\nChecking if specific app_ids {sample_app_ids} are present in combined_df:")
for app_id in sample_app_ids:
    is_present = app_id in unique_app_ids
    print(f"App ID {app_id} present: {is_present}")

# Summary of app_id ranges to check for unusual values
print("\nSummary statistics for app_id column:")
print(combined_df['app_id'].describe())

import json

# Load games_metadata.json as a list of JSON objects, one per line
games_metadata = []
with open('/content/drive/MyDrive/steam_recommender/games_metadata.json', 'r') as f:
    for line in f:
        try:
            games_metadata.append(json.loads(line.strip()))
        except json.JSONDecodeError as e:
            print(f"Error decoding line: {line}\nError: {e}")

def get_game_info(app_id, combined_df, games_csv, games_metadata):
    """
    Retrieve game information based on app_id, starting with combined_df.
    Fallback to games.csv and games_metadata.json if app_id is missing from combined_df.
    """
    # First, check in combined_df
    if app_id in combined_df['app_id'].values:
        game_info = combined_df[combined_df['app_id'] == app_id][['title', 'description']]
        return game_info

    # Fallback to games.csv
    elif app_id in games_csv['app_id'].values:
        # Check if 'description' exists in games_csv
        if 'description' in games_csv.columns:
            game_info = games_csv[games_csv['app_id'] == app_id][['title', 'description']]
        else:
            game_info = games_csv[games_csv['app_id'] == app_id][['title']]
            game_info['description'] = "No description available."  # Default message
        print(f"App ID {app_id} found in games.csv.")
        return game_info

    # Fallback to games_metadata.json
    else:
        metadata_entry = next((entry for entry in games_metadata if entry['app_id'] == app_id), None)
        if metadata_entry:
            title = metadata_entry.get('title', 'Unknown Title')
            description = metadata_entry.get('description', 'No description available.')
            print(f"App ID {app_id} found in games_metadata.json.")
            return pd.DataFrame({'title': [title], 'description': [description]})

    # # If not found anywhere
    print(f"App ID {app_id} not found in any data source.")
    return pd.DataFrame(columns=['title', 'description'])

# Example usage
app_id_to_check = 1571600
game_info = get_game_info(app_id_to_check, combined_df, games_csv, games_metadata)
print("Game info:", game_info)



# Define test cases with unique user messages
test_cases = [
    "Can you recommend some games similar to Skyrim?",
    "I'm into horror games, could you recommend something similar to Outlast?",
    "Do you have any recommendations for multiplayer FPS games?",
    "My Steam ID is 12345678.",
    "I didn’t enjoy playing Cyberpunk 2077.",
    "Can you recommend an indie game?",
    "Do you have any games that are similar to The Sims?",
    "Can you recommend some story-rich RPGs?",
    "I love Cyberpunk 2077, what other sci-fi games can I try?",
    "I'm looking for a game with co-op multiplayer.",
    "I’m interested in puzzle games, can you suggest something?",
    "Any recommendations for strategy games?",
    "I need a recommendation for kids' games.",
    "Do you have a suggestion for a good racing game?",
    "Can you find games similar to Half-Life?"
]

# Function to run all test cases
def run_test_cases(test_cases, session):
    for i, user_message in enumerate(test_cases):
        print(f"Test Case {i+1}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")
        print("-" * 50)

# Initialize a new user session
session = UserSession()

# Run the test cases
run_test_cases(test_cases, session)



# Define additional unique test cases with a mix of relevant and unexpected queries
test_cases = [
    "Can you recommend some games similar to Skyrim?",  # Classic recommendation query
    "I'm into horror games, could you recommend something similar to Outlast?",  # Genre-based query
    "Do you have any recommendations for multiplayer FPS games?",  # Multiplayer and genre request
    "My Steam ID is 12345678.",  # Steam ID input to test personalized recommendations
    "I didn’t enjoy playing Cyberpunk 2077.",  # Feedback on disliked game
    "I love fantasy games with magic. Any suggestions?",  # Theme-specific interest in magic and fantasy
    "What's a good RPG with a compelling story?",  # Request for a genre with a specific feature (story)
    "Do you know of any educational games for children?",  # Non-standard gaming genre (educational for kids)
    "Could you recommend some games with relaxing gameplay?",  # Request for a specific mood/style of gameplay
    "Any good co-op games to play with friends?",  # Co-op game recommendation
    "I'm looking for games with deep lore. Got any suggestions?",  # Interest in games with deep lore
    "Can you recommend a movie similar to Lord of the Rings?",  # Completely off-topic query (movie recommendation)
    "I need a recipe for a quick pasta dish.",  # Unexpected question about cooking
    "Tell me a fun fact about space!",  # Random, non-gaming educational request
    "What’s the best way to learn Python programming?",  # Question unrelated to gaming, for versatility check
]

# Function to run all test cases
def run_test_cases(test_cases, session):
    for i, user_message in enumerate(test_cases):
        print(f"Test Case {i+1}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")
        print("-" * 50)

# Initialize a new user session
session = UserSession()

# Run the test cases
run_test_cases(test_cases, session)

# Updated function to reset session for each test case
def run_test_cases_with_reset(test_cases):
    for i, user_message in enumerate(test_cases):
        # Reset the user session before each test case to prevent carryover
        session = UserSession()

        print(f"Test Case {i+1}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")
        print("-" * 50)

# Define unique test cases, including off-topic and general knowledge queries
test_cases = [
    "Can you recommend some games similar to Skyrim?",  # Classic recommendation query
    "I'm into horror games, could you recommend something similar to Outlast?",  # Genre-specific request
    "Do you have any recommendations for multiplayer FPS games?",  # Multiplayer focus
    "My Steam ID is 12345678.",  # Steam ID input for personalization
    "I didn’t enjoy playing Cyberpunk 2077.",  # Feedback on disliked game
    "I love fantasy games with magic. Any suggestions?",  # Theme-specific for fantasy
    "What's a good RPG with a compelling story?",  # Genre with story focus
    "Do you know of any educational games for children?",  # Educational game request
    "Could you recommend some games with relaxing gameplay?",  # Relaxed gameplay style
    "Any good co-op games to play with friends?",  # Co-op multiplayer games
    "I'm looking for games with deep lore. Got any suggestions?",  # Games with lore focus
    "Can you recommend a movie similar to Lord of the Rings?",  # Off-topic movie recommendation
    "I need a recipe for a quick pasta dish.",  # Unexpected cooking-related query
    "Tell me a fun fact about space!",  # Random educational request
    "What’s the best way to learn Python programming?",  # Non-gaming, programming-related query
]

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)



# Function to run test cases and reset session for each case
def run_test_cases_with_reset(test_cases):
    for i, user_message in enumerate(test_cases):
        # Reset the user session before each test case to prevent carryover
        session = UserSession()

        print(f"Test Case {i+1}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")
        print("-" * 50)

# Define unique test cases, including off-topic and general knowledge queries
test_cases = [
    "Can you recommend some games similar to Skyrim?",  # Classic recommendation query
    "I'm into horror games, could you recommend something similar to Outlast?",  # Genre-specific request
    "Do you have any recommendations for multiplayer FPS games?",  # Multiplayer focus
    "My Steam ID is 12345678.",  # Steam ID input for personalization
    "I didn’t enjoy playing Cyberpunk 2077.",  # Feedback on disliked game
    "I love fantasy games with magic. Any suggestions?",  # Theme-specific for fantasy
    "What's a good RPG with a compelling story?",  # Genre with story focus
    "Do you know of any educational games for children?",  # Educational game request
    "Could you recommend some games with relaxing gameplay?",  # Relaxed gameplay style
    "Any good co-op games to play with friends?",  # Co-op multiplayer games
    "I'm looking for games with deep lore. Got any suggestions?",  # Games with lore focus
    "Can you recommend a movie similar to Lord of the Rings?",  # Off-topic movie recommendation
    "I need a recipe for a quick pasta dish.",  # Unexpected cooking-related query
    "Tell me a fun fact about space!",  # Random educational request
    "What’s the best way to learn Python programming?",  # Non-gaming, programming-related query
]

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)



"""### **USE CASES**

"""

# Function to run test cases and reset session for each case
def run_test_cases_with_reset(test_cases):
    for i, user_message in enumerate(test_cases):
        # Reset the user session before each test case to prevent carryover
        session = UserSession()

        print(f"Test Case {i+1}:")
        print(f"User Message: {user_message}")
        chatbot_response = recommend_games(user_message, session)
        print(f"Chatbot Response:\n{chatbot_response}\n")
        print("-" * 50)

# Define unique test cases, including off-topic and game-specific queries
test_cases = [
    "Can you recommend some games similar to Skyrim?",  # Game recommendation request
    "I'm into horror games, could you recommend something similar to Outlast?",  # Genre-specific recommendation
    "Do you have any recommendations for multiplayer FPS games?",  # Multiplayer FPS focus
    "My Steam ID is 12345678.",  # Providing Steam ID
    "I didn’t enjoy playing Cyberpunk 2077.",  # Feedback on a disliked game
    "I love fantasy games with magic. Any suggestions?",  # Fantasy genre request
    "What's a good RPG with a compelling story?",  # RPG story-driven recommendation
    "Do you know of any educational games for children?",  # Educational game request
    "Could you recommend some games with relaxing gameplay?",  # Calm/relaxing games
    "Any good co-op games to play with friends?",  # Co-op multiplayer game request
    "I'm looking for games with deep lore. Got any suggestions?",  # Games with rich lore
    "Can you recommend a movie similar to Lord of the Rings?",  # Off-topic movie request
    "I need a recipe for a quick pasta dish.",  # Non-game cooking query
    "Tell me a fun fact about space!",  # Random educational query
    "What’s the best way to learn Python programming?",  # Off-topic programming question
]

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)



# STILL TESTING

# Define unique test cases, including off-topic and game-specific queries
test_cases = [
    "Can you recommend some games similar to Skyrim?",  # Game recommendation request
    "I'm into horror games, could you recommend something similar to Outlast?",  # Genre-specific recommendation
    "Do you have any recommendations for multiplayer FPS games?",  # Multiplayer FPS focus
    "My Steam ID is 12345678.",  # Providing Steam ID
    "I didn’t enjoy playing Cyberpunk 2077.",  # Feedback on a disliked game
    "I love fantasy games with magic. Any suggestions?",  # Fantasy genre request
    "What's a good RPG with a compelling story?",  # RPG story-driven recommendation
    "Do you know of any educational games for children?",  # Educational game request
    "Could you recommend some games with relaxing gameplay?",  # Calm/relaxing games
    "Any good co-op games to play with friends?",  # Co-op multiplayer game request
    "I'm looking for games with deep lore. Got any suggestions?",  # Games with rich lore
    "Can you recommend a movie similar to Lord of the Rings?",  # Off-topic movie request
    "I need a recipe for a quick pasta dish.",  # Non-game cooking query
    "Tell me a fun fact about space!",  # Random educational query
    "What’s the best way to learn Python programming?",  # Off-topic programming question
]

# Run the test cases with session reset
run_test_cases_with_reset(test_cases)